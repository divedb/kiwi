<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>kiwi: kiwi::IOBuf Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">kiwi<span id="projectnumber">&#160;This project is a codebase written in C++.</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classkiwi_1_1_i_o_buf.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classkiwi_1_1_i_o_buf-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kiwi::IOBuf Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="iobuf_8hh_source.html">iobuf.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_fill_iov_result.html">FillIovResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_heap_full_storage.html">HeapFullStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_heap_prefix.html">HeapPrefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use free for size &gt;= 4GB since we can store only 32 bits in the size var.  <a href="structkiwi_1_1_i_o_buf_1_1_heap_prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_heap_storage.html">HeapStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6ec828de9687ff9579cbb0b79acb608d" id="r_a6ec828de9687ff9579cbb0b79acb608d"><td class="memItemLeft" align="right" valign="top"><a id="a6ec828de9687ff9579cbb0b79acb608d" name="a6ec828de9687ff9579cbb0b79acb608d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CreateOp</b> { <b>kCreate</b>
 }</td></tr>
<tr class="separator:a6ec828de9687ff9579cbb0b79acb608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b7ebfb81ae65c9121c1a381920d38" id="r_a5b7b7ebfb81ae65c9121c1a381920d38"><td class="memItemLeft" align="right" valign="top"><a id="a5b7b7ebfb81ae65c9121c1a381920d38" name="a5b7b7ebfb81ae65c9121c1a381920d38"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>WrapBufferOp</b> { <b>kWrapBuffer</b>
 }</td></tr>
<tr class="separator:a5b7b7ebfb81ae65c9121c1a381920d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444b86d0ce32f7dfa5fce3e76125bed8" id="r_a444b86d0ce32f7dfa5fce3e76125bed8"><td class="memItemLeft" align="right" valign="top"><a id="a444b86d0ce32f7dfa5fce3e76125bed8" name="a444b86d0ce32f7dfa5fce3e76125bed8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TakeOwnershipOp</b> { <b>kTaskeOwnership</b>
 }</td></tr>
<tr class="separator:a444b86d0ce32f7dfa5fce3e76125bed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7105edb5c10f0324f55026eca8afcc" id="r_a2c7105edb5c10f0324f55026eca8afcc"><td class="memItemLeft" align="right" valign="top"><a id="a2c7105edb5c10f0324f55026eca8afcc" name="a2c7105edb5c10f0324f55026eca8afcc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CopyBufferOp</b> { <b>kCopyBuffer</b>
 }</td></tr>
<tr class="separator:a2c7105edb5c10f0324f55026eca8afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaba74f5d72831a14dcf1ad57c7327bd" id="r_acaba74f5d72831a14dcf1ad57c7327bd"><td class="memItemLeft" align="right" valign="top"><a id="acaba74f5d72831a14dcf1ad57c7327bd" name="acaba74f5d72831a14dcf1ad57c7327bd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SizedFree</b> { <b>kSizedFree</b>
 }</td></tr>
<tr class="separator:acaba74f5d72831a14dcf1ad57c7327bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96949430f003951037c0a4bc6d648d82" id="r_a96949430f003951037c0a4bc6d648d82"><td class="memItemLeft" align="right" valign="top"><a id="a96949430f003951037c0a4bc6d648d82" name="a96949430f003951037c0a4bc6d648d82"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>CombinedOption</b> { <b>kDefault</b>
, <b>kCombined</b>
, <b>kSeparate</b>
 }</td></tr>
<tr class="separator:a96949430f003951037c0a4bc6d648d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e5d8df23c628c4fb1bf56ec2c72735" id="r_a47e5d8df23c628c4fb1bf56ec2c72735"><td class="memItemLeft" align="right" valign="top"><a id="a47e5d8df23c628c4fb1bf56ec2c72735" name="a47e5d8df23c628c4fb1bf56ec2c72735"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = uint8_t</td></tr>
<tr class="separator:a47e5d8df23c628c4fb1bf56ec2c72735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9867c24bf9ca1ff8be57f87fb3963" id="r_a8ef9867c24bf9ca1ff8be57f87fb3963"><td class="memItemLeft" align="right" valign="top"><a id="a8ef9867c24bf9ca1ff8be57f87fb3963" name="a8ef9867c24bf9ca1ff8be57f87fb3963"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = <a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:a8ef9867c24bf9ca1ff8be57f87fb3963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6aaffb93c7c2159f77f779192d1775" id="r_a8a6aaffb93c7c2159f77f779192d1775"><td class="memItemLeft" align="right" valign="top"><a id="a8a6aaffb93c7c2159f77f779192d1775" name="a8a6aaffb93c7c2159f77f779192d1775"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = <a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a></td></tr>
<tr class="separator:a8a6aaffb93c7c2159f77f779192d1775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c12c699fe3b4850d0aa185f2d3e8da" id="r_a72c12c699fe3b4850d0aa185f2d3e8da"><td class="memItemLeft" align="right" valign="top"><a id="a72c12c699fe3b4850d0aa185f2d3e8da" name="a72c12c699fe3b4850d0aa185f2d3e8da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ByteRange</b> = <a class="el" href="classkiwi_1_1span.html">kiwi::span</a>&lt;uint8_t&gt;</td></tr>
<tr class="separator:a72c12c699fe3b4850d0aa185f2d3e8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad078d626645936f6cc418fc5a15033f1" id="r_ad078d626645936f6cc418fc5a15033f1"><td class="memItemLeft" align="right" valign="top"><a id="ad078d626645936f6cc418fc5a15033f1" name="ad078d626645936f6cc418fc5a15033f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FreeFunction</b> = void (*)(void* buf, void* user_data)</td></tr>
<tr class="separator:ad078d626645936f6cc418fc5a15033f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f6071e9f9d7fd8f11da8755f5809705" id="r_a7f6071e9f9d7fd8f11da8755f5809705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f6071e9f9d7fd8f11da8755f5809705">IOBuf</a> (CreateOp, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>)</td></tr>
<tr class="separator:a7f6071e9f9d7fd8f11da8755f5809705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da85cf118a667a0f9267bd3e580c95c" id="r_a0da85cf118a667a0f9267bd3e580c95c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0da85cf118a667a0f9267bd3e580c95c">IOBuf</a> (TakeOwnershipOp op, void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:a0da85cf118a667a0f9267bd3e580c95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e9c470caa96aec01ba4c5a0880d8c1" id="r_a99e9c470caa96aec01ba4c5a0880d8c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e9c470caa96aec01ba4c5a0880d8c1">IOBuf</a> (TakeOwnershipOp op, void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, std::size_t length, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:a99e9c470caa96aec01ba4c5a0880d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee035419221d92a93e6658bc5520803" id="r_a0ee035419221d92a93e6658bc5520803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ee035419221d92a93e6658bc5520803">IOBuf</a> (TakeOwnershipOp, void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, std::size_t offset, std::size_t length, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:a0ee035419221d92a93e6658bc5520803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df8c49db49fbda48c89bf51bd328e82" id="r_a5df8c49db49fbda48c89bf51bd328e82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df8c49db49fbda48c89bf51bd328e82">IOBuf</a> (TakeOwnershipOp, SizedFree, void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, std::size_t offset, std::size_t length, bool free_on_error=true)</td></tr>
<tr class="separator:a5df8c49db49fbda48c89bf51bd328e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84f84ca1454238aa2531223d420a78" id="r_a2b84f84ca1454238aa2531223d420a78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b84f84ca1454238aa2531223d420a78">IOBuf</a> () noexcept</td></tr>
<tr class="separator:a2b84f84ca1454238aa2531223d420a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca1a066836e9b3b5d8f326851ba487" id="r_a21ca1a066836e9b3b5d8f326851ba487"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21ca1a066836e9b3b5d8f326851ba487">IOBuf</a> (const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;other)</td></tr>
<tr class="separator:a21ca1a066836e9b3b5d8f326851ba487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23324e396a3a95880e9897f9286c0731" id="r_a23324e396a3a95880e9897f9286c0731"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23324e396a3a95880e9897f9286c0731">IOBuf</a> (<a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a23324e396a3a95880e9897f9286c0731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf9feefdc07aa06d61ca2c58f81fa4" id="r_a3ebf9feefdc07aa06d61ca2c58f81fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ebf9feefdc07aa06d61ca2c58f81fa4">operator=</a> (<a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a3ebf9feefdc07aa06d61ca2c58f81fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17f40ce23314a50600522d1fa78a485" id="r_ae17f40ce23314a50600522d1fa78a485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17f40ce23314a50600522d1fa78a485">operator=</a> (const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;other)</td></tr>
<tr class="separator:ae17f40ce23314a50600522d1fa78a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00383234824ff95f192e09d8d77b0c6" id="r_ac00383234824ff95f192e09d8d77b0c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac00383234824ff95f192e09d8d77b0c6">IOBuf</a> (WrapBufferOp op, <a class="el" href="classkiwi_1_1span.html">ByteRange</a> br) noexcept</td></tr>
<tr class="separator:ac00383234824ff95f192e09d8d77b0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8145236efb0eb62fd99871e94e0d49d" id="r_af8145236efb0eb62fd99871e94e0d49d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8145236efb0eb62fd99871e94e0d49d">IOBuf</a> (WrapBufferOp op, const void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>) noexcept</td></tr>
<tr class="separator:af8145236efb0eb62fd99871e94e0d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d432d9c1571f0edef9627ca515f87f" id="r_a39d432d9c1571f0edef9627ca515f87f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39d432d9c1571f0edef9627ca515f87f">IOBuf</a> (CopyBufferOp op, <a class="el" href="classkiwi_1_1span.html">ByteRange</a> br, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:a39d432d9c1571f0edef9627ca515f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde7c357d8a93da6e41da0231a3c69f" id="r_a5cde7c357d8a93da6e41da0231a3c69f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cde7c357d8a93da6e41da0231a3c69f">IOBuf</a> (CopyBufferOp op, const void *buf, std::size_t size, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:a5cde7c357d8a93da6e41da0231a3c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db17d779c632642dfbd1cd3f3d55b2f" id="r_a2db17d779c632642dfbd1cd3f3d55b2f"><td class="memItemLeft" align="right" valign="top"><a id="a2db17d779c632642dfbd1cd3f3d55b2f" name="a2db17d779c632642dfbd1cd3f3d55b2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IOBuf</b> (CopyBufferOp op, std::string_view buf, std::size_t headroom=0, std::size_t minTailroom=0)</td></tr>
<tr class="separator:a2db17d779c632642dfbd1cd3f3d55b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcdd5cd5f46ee3a9e6904dd68209b29" id="r_addcdd5cd5f46ee3a9e6904dd68209b29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addcdd5cd5f46ee3a9e6904dd68209b29">~IOBuf</a> ()</td></tr>
<tr class="separator:addcdd5cd5f46ee3a9e6904dd68209b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa66a4d02d63c3eee6a85ba4a726672b" id="r_afa66a4d02d63c3eee6a85ba4a726672b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa66a4d02d63c3eee6a85ba4a726672b">empty</a> () const</td></tr>
<tr class="separator:afa66a4d02d63c3eee6a85ba4a726672b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708944d0de466a93fda5102be9ceb938" id="r_a708944d0de466a93fda5102be9ceb938"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data</a> () const</td></tr>
<tr class="separator:a708944d0de466a93fda5102be9ceb938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c8383995275986e0534b77a6438a31" id="r_a05c8383995275986e0534b77a6438a31"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05c8383995275986e0534b77a6438a31">WritableData</a> ()</td></tr>
<tr class="separator:a05c8383995275986e0534b77a6438a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b29fcaa18008ff3ba19d93303a4082" id="r_a27b29fcaa18008ff3ba19d93303a4082"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b29fcaa18008ff3ba19d93303a4082">Tail</a> () const</td></tr>
<tr class="separator:a27b29fcaa18008ff3ba19d93303a4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77919d0f48c5fe6895b7fcfa4e48016b" id="r_a77919d0f48c5fe6895b7fcfa4e48016b"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77919d0f48c5fe6895b7fcfa4e48016b">WritableTail</a> ()</td></tr>
<tr class="separator:a77919d0f48c5fe6895b7fcfa4e48016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73808ff60c3bdbd250e0a4dbf556dd45" id="r_a73808ff60c3bdbd250e0a4dbf556dd45"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length</a> () const</td></tr>
<tr class="separator:a73808ff60c3bdbd250e0a4dbf556dd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9c776ad615d21567b831945c1529d5" id="r_a9f9c776ad615d21567b831945c1529d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom</a> () const</td></tr>
<tr class="separator:a9f9c776ad615d21567b831945c1529d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23acbdc67f657564e646efe8cd9a6fa3" id="r_a23acbdc67f657564e646efe8cd9a6fa3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom</a> () const</td></tr>
<tr class="separator:a23acbdc67f657564e646efe8cd9a6fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679f13d5591ed0e4963eb9cc078e9486" id="r_a679f13d5591ed0e4963eb9cc078e9486"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679f13d5591ed0e4963eb9cc078e9486">Buffer</a> () const</td></tr>
<tr class="separator:a679f13d5591ed0e4963eb9cc078e9486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a17715736ebb6e17e0a1f22fe46fa9a" id="r_a2a17715736ebb6e17e0a1f22fe46fa9a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a17715736ebb6e17e0a1f22fe46fa9a">WritableBuffer</a> ()</td></tr>
<tr class="separator:a2a17715736ebb6e17e0a1f22fe46fa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b138b44fdf260ac04ad2c3f35a3f2f" id="r_a98b138b44fdf260ac04ad2c3f35a3f2f"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b138b44fdf260ac04ad2c3f35a3f2f">BufferEnd</a> () const</td></tr>
<tr class="separator:a98b138b44fdf260ac04ad2c3f35a3f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adefcda03cb041c68d4341ef4eec966" id="r_a6adefcda03cb041c68d4341ef4eec966"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a> () const</td></tr>
<tr class="separator:a6adefcda03cb041c68d4341ef4eec966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1b72cbad61f1afcc081eaad99590d5" id="r_aea1b72cbad61f1afcc081eaad99590d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea1b72cbad61f1afcc081eaad99590d5">Next</a> ()</td></tr>
<tr class="separator:aea1b72cbad61f1afcc081eaad99590d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8c881127b62ed7370552cba6d1db21" id="r_aeb8c881127b62ed7370552cba6d1db21"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb8c881127b62ed7370552cba6d1db21">Next</a> () const</td></tr>
<tr class="separator:aeb8c881127b62ed7370552cba6d1db21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6cfe3b15ad1c481d93926b3c0337a4" id="r_a6e6cfe3b15ad1c481d93926b3c0337a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6cfe3b15ad1c481d93926b3c0337a4">Prev</a> ()</td></tr>
<tr class="separator:a6e6cfe3b15ad1c481d93926b3c0337a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34fb6470113b215c11dc1b84296ac50" id="r_ad34fb6470113b215c11dc1b84296ac50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad34fb6470113b215c11dc1b84296ac50">Prev</a> () const</td></tr>
<tr class="separator:ad34fb6470113b215c11dc1b84296ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff66dd7c31c9340d6b9a64b4026d1b5f" id="r_aff66dd7c31c9340d6b9a64b4026d1b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff66dd7c31c9340d6b9a64b4026d1b5f">Advance</a> (std::size_t amount)</td></tr>
<tr class="separator:aff66dd7c31c9340d6b9a64b4026d1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc048704e057d61e58e09367661d2454" id="r_adc048704e057d61e58e09367661d2454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc048704e057d61e58e09367661d2454">Retreat</a> (std::size_t amount)</td></tr>
<tr class="separator:adc048704e057d61e58e09367661d2454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756590a6a2922b5aa48dc77d45f93405" id="r_a756590a6a2922b5aa48dc77d45f93405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a756590a6a2922b5aa48dc77d45f93405">prepend</a> (std::size_t amount)</td></tr>
<tr class="separator:a756590a6a2922b5aa48dc77d45f93405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984449ddf4541eca038b1b4f7b93dd97" id="r_a984449ddf4541eca038b1b4f7b93dd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984449ddf4541eca038b1b4f7b93dd97">Append</a> (std::size_t amount)</td></tr>
<tr class="separator:a984449ddf4541eca038b1b4f7b93dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d9b6d522b325ff3d8ba04dcafe3203" id="r_ab3d9b6d522b325ff3d8ba04dcafe3203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d9b6d522b325ff3d8ba04dcafe3203">TrimStart</a> (std::size_t amount)</td></tr>
<tr class="separator:ab3d9b6d522b325ff3d8ba04dcafe3203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54ae0c205585a88308117dd3e8354e" id="r_adb54ae0c205585a88308117dd3e8354e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb54ae0c205585a88308117dd3e8354e">TrimEnd</a> (std::size_t amount)</td></tr>
<tr class="separator:adb54ae0c205585a88308117dd3e8354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c768ff0dfc147881a75afc1fe403ea" id="r_ab4c768ff0dfc147881a75afc1fe403ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4c768ff0dfc147881a75afc1fe403ea">TrimWritableTail</a> (std::size_t amount)</td></tr>
<tr class="separator:ab4c768ff0dfc147881a75afc1fe403ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840a75e5d2f1cc2fb467260fda98ea52" id="r_a840a75e5d2f1cc2fb467260fda98ea52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840a75e5d2f1cc2fb467260fda98ea52">clear</a> ()</td></tr>
<tr class="separator:a840a75e5d2f1cc2fb467260fda98ea52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e23d4cbb808550af93558459aaa092d" id="r_a6e23d4cbb808550af93558459aaa092d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e23d4cbb808550af93558459aaa092d">reserve</a> (std::size_t min_head_room, std::size_t min_tail_room)</td></tr>
<tr class="separator:a6e23d4cbb808550af93558459aaa092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327d1deedf8559d086fe372e7de6c753" id="r_a327d1deedf8559d086fe372e7de6c753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained</a> () const</td></tr>
<tr class="separator:a327d1deedf8559d086fe372e7de6c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb832f44649118ca6ba0f2d09c4de86" id="r_a2fb832f44649118ca6ba0f2d09c4de86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb832f44649118ca6ba0f2d09c4de86">CountChainElements</a> () const</td></tr>
<tr class="separator:a2fb832f44649118ca6ba0f2d09c4de86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fefcb935fa0e189324e07d03702320" id="r_a78fefcb935fa0e189324e07d03702320"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fefcb935fa0e189324e07d03702320">ComputeChainDataLength</a> () const</td></tr>
<tr class="separator:a78fefcb935fa0e189324e07d03702320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0f7ef8d07332c8518dbe1884357464" id="r_afc0f7ef8d07332c8518dbe1884357464"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0f7ef8d07332c8518dbe1884357464">ComputeChainCapacity</a> () const</td></tr>
<tr class="separator:afc0f7ef8d07332c8518dbe1884357464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21785f202ca90b05faa6d4b9483c2206" id="r_a21785f202ca90b05faa6d4b9483c2206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21785f202ca90b05faa6d4b9483c2206">AppendToChain</a> (std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;iobuf)</td></tr>
<tr class="separator:a21785f202ca90b05faa6d4b9483c2206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cce2803d306fcb964a3087b8a030e7" id="r_a39cce2803d306fcb964a3087b8a030e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39cce2803d306fcb964a3087b8a030e7">InsertAfterThisOne</a> (std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;iobuf)</td></tr>
<tr class="separator:a39cce2803d306fcb964a3087b8a030e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c15c5b8a4558580586e7b01940c48d6" id="r_a8c15c5b8a4558580586e7b01940c48d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c15c5b8a4558580586e7b01940c48d6">PrependChain</a> (std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;iobuf)</td></tr>
<tr class="separator:a8c15c5b8a4558580586e7b01940c48d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feebf266b48e22f583c927a86a98cd0" id="r_a7feebf266b48e22f583c927a86a98cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7feebf266b48e22f583c927a86a98cd0">AppendChain</a> (std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;iobuf)</td></tr>
<tr class="separator:a7feebf266b48e22f583c927a86a98cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd21c00ea100c65d0a01fb07d70303" id="r_a45cd21c00ea100c65d0a01fb07d70303"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45cd21c00ea100c65d0a01fb07d70303">Unlink</a> ()</td></tr>
<tr class="separator:a45cd21c00ea100c65d0a01fb07d70303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8005e47b46e804cf63c89614a2ff2b" id="r_afc8005e47b46e804cf63c89614a2ff2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8005e47b46e804cf63c89614a2ff2b">pop</a> ()</td></tr>
<tr class="separator:afc8005e47b46e804cf63c89614a2ff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c0af6870164ad98f8470ef984d8fe2" id="r_af3c0af6870164ad98f8470ef984d8fe2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3c0af6870164ad98f8470ef984d8fe2">SeparateChain</a> (<a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *head, <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *tail)</td></tr>
<tr class="separator:af3c0af6870164ad98f8470ef984d8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d427b0dc2129015373da3e25c52d15" id="r_ad6d427b0dc2129015373da3e25c52d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d427b0dc2129015373da3e25c52d15">IsShared</a> () const</td></tr>
<tr class="separator:ad6d427b0dc2129015373da3e25c52d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb8092a47d0323280174c78d61c3c2" id="r_a60bb8092a47d0323280174c78d61c3c2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60bb8092a47d0323280174c78d61c3c2">GetUserData</a> () const noexcept</td></tr>
<tr class="separator:a60bb8092a47d0323280174c78d61c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e1ea256d1bd6bbbdafdea48dfed2eb" id="r_a28e1ea256d1bd6bbbdafdea48dfed2eb"><td class="memItemLeft" align="right" valign="top">FreeFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28e1ea256d1bd6bbbdafdea48dfed2eb">GetFreeFn</a> () const noexcept</td></tr>
<tr class="separator:a28e1ea256d1bd6bbbdafdea48dfed2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459ea5071c51a5015b35dafeae183ff0" id="r_a459ea5071c51a5015b35dafeae183ff0"><td class="memTemplParams" colspan="2">template&lt;typename Observer&gt; </td></tr>
<tr class="memitem:a459ea5071c51a5015b35dafeae183ff0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a459ea5071c51a5015b35dafeae183ff0">AppendSharedInfoObserver</a> (Observer &amp;&amp;observer)</td></tr>
<tr class="separator:a459ea5071c51a5015b35dafeae183ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206bc7d596ee0679fb459e6f44f2756" id="r_ae206bc7d596ee0679fb459e6f44f2756"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae206bc7d596ee0679fb459e6f44f2756">IsManaged</a> () const</td></tr>
<tr class="separator:ae206bc7d596ee0679fb459e6f44f2756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab044ec809760986f38f05f56048c90ce" id="r_ab044ec809760986f38f05f56048c90ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab044ec809760986f38f05f56048c90ce">IsManagedOne</a> () const noexcept</td></tr>
<tr class="separator:ab044ec809760986f38f05f56048c90ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af155b2c4fc618c19a2fea14c6d5e6e8e" id="r_af155b2c4fc618c19a2fea14c6d5e6e8e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af155b2c4fc618c19a2fea14c6d5e6e8e">ApproximateShareCountOne</a> () const</td></tr>
<tr class="separator:af155b2c4fc618c19a2fea14c6d5e6e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2272b3bce96c3abb4d0943ef4fc9b" id="r_acfe2272b3bce96c3abb4d0943ef4fc9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe2272b3bce96c3abb4d0943ef4fc9b">IsSharedOne</a> () const noexcept</td></tr>
<tr class="separator:acfe2272b3bce96c3abb4d0943ef4fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02310eb3c6cfac120d0b7d962097e6ab" id="r_a02310eb3c6cfac120d0b7d962097e6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare</a> ()</td></tr>
<tr class="separator:a02310eb3c6cfac120d0b7d962097e6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a25efa83923b3904420315cfcbbbd0a" id="r_a3a25efa83923b3904420315cfcbbbd0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a25efa83923b3904420315cfcbbbd0a">UnshareOne</a> ()</td></tr>
<tr class="separator:a3a25efa83923b3904420315cfcbbbd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d64b8e2e59d867eb7d73db6a0500c3" id="r_aa3d64b8e2e59d867eb7d73db6a0500c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3d64b8e2e59d867eb7d73db6a0500c3">MarkExternallyShared</a> ()</td></tr>
<tr class="separator:aa3d64b8e2e59d867eb7d73db6a0500c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca41d072b060f79a73bc3e6b67dca4bb" id="r_aca41d072b060f79a73bc3e6b67dca4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca41d072b060f79a73bc3e6b67dca4bb">MarkExternallySharedOne</a> ()</td></tr>
<tr class="separator:aca41d072b060f79a73bc3e6b67dca4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c24eab145eaf298ac70d02eee0baa3d" id="r_a2c24eab145eaf298ac70d02eee0baa3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c24eab145eaf298ac70d02eee0baa3d">MakeManaged</a> ()</td></tr>
<tr class="separator:a2c24eab145eaf298ac70d02eee0baa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102404f55b2abc56d44bdcd10a5e4f08" id="r_a102404f55b2abc56d44bdcd10a5e4f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a102404f55b2abc56d44bdcd10a5e4f08">MakeManagedOne</a> ()</td></tr>
<tr class="separator:a102404f55b2abc56d44bdcd10a5e4f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc67e55ad77e64bdecd1985c89a1d3f0" id="r_acc67e55ad77e64bdecd1985c89a1d3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1span.html">ByteRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce</a> ()</td></tr>
<tr class="separator:acc67e55ad77e64bdecd1985c89a1d3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330906fb632d710757b90ad5a3c95f67" id="r_a330906fb632d710757b90ad5a3c95f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1span.html">ByteRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a330906fb632d710757b90ad5a3c95f67">CoalesceWithHeadroomTailroom</a> (std::size_t new_head_room, std::size_t new_tail_room)</td></tr>
<tr class="separator:a330906fb632d710757b90ad5a3c95f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01aa5a69e98470d66c113e8aafb06d1" id="r_ad01aa5a69e98470d66c113e8aafb06d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01aa5a69e98470d66c113e8aafb06d1">Gather</a> (std::size_t contiguous_length)</td></tr>
<tr class="separator:ad01aa5a69e98470d66c113e8aafb06d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441bac0ab805e616558127ff37208d76" id="r_a441bac0ab805e616558127ff37208d76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone</a> () const</td></tr>
<tr class="separator:a441bac0ab805e616558127ff37208d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7ae7b52fbea81b71d468e67cc7cd2" id="r_ac0f7ae7b52fbea81b71d468e67cc7cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0f7ae7b52fbea81b71d468e67cc7cd2">CloneAsValue</a> () const</td></tr>
<tr class="separator:ac0f7ae7b52fbea81b71d468e67cc7cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb771a8c582355c71472a2bdb36e9e2" id="r_a4bb771a8c582355c71472a2bdb36e9e2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb771a8c582355c71472a2bdb36e9e2">CloneOne</a> () const</td></tr>
<tr class="separator:a4bb771a8c582355c71472a2bdb36e9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54945401269798c696f3f17c43a5d6aa" id="r_a54945401269798c696f3f17c43a5d6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54945401269798c696f3f17c43a5d6aa">CloneOneAsValue</a> () const</td></tr>
<tr class="separator:a54945401269798c696f3f17c43a5d6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1abe3f7e7b593375a4a3bc9e61883" id="r_a77b1abe3f7e7b593375a4a3bc9e61883"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b1abe3f7e7b593375a4a3bc9e61883">CloneCoalesced</a> () const</td></tr>
<tr class="separator:a77b1abe3f7e7b593375a4a3bc9e61883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d84443564604c8b79fb2065ee741f" id="r_a304d84443564604c8b79fb2065ee741f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a304d84443564604c8b79fb2065ee741f">CloneCoalescedWithHeadroomTailroom</a> (std::size_t new_head_room, std::size_t new_tail_room) const</td></tr>
<tr class="separator:a304d84443564604c8b79fb2065ee741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc296707072f0b490a1508e6e65de8ac" id="r_acc296707072f0b490a1508e6e65de8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc296707072f0b490a1508e6e65de8ac">CloneCoalescedAsValue</a> () const</td></tr>
<tr class="separator:acc296707072f0b490a1508e6e65de8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363756c29ae03b864d2daca8c4c0277e" id="r_a363756c29ae03b864d2daca8c4c0277e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a363756c29ae03b864d2daca8c4c0277e">CloneCoalescedAsValueWithHeadroomTailroom</a> (std::size_t new_head_room, std::size_t new_tail_room) const</td></tr>
<tr class="separator:a363756c29ae03b864d2daca8c4c0277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67aa00c7b4f098ec567446e5f80efc3" id="r_ae67aa00c7b4f098ec567446e5f80efc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67aa00c7b4f098ec567446e5f80efc3">CloneInto</a> (<a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;other) const</td></tr>
<tr class="separator:ae67aa00c7b4f098ec567446e5f80efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d8e92a27d6269fc75ec508ff9f4239" id="r_a55d8e92a27d6269fc75ec508ff9f4239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d8e92a27d6269fc75ec508ff9f4239">CloneOneInto</a> (<a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;other) const</td></tr>
<tr class="separator:a55d8e92a27d6269fc75ec508ff9f4239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b47ae84869903d1c7e60c2fff9866d5" id="r_a7b47ae84869903d1c7e60c2fff9866d5"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a7b47ae84869903d1c7e60c2fff9866d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b47ae84869903d1c7e60c2fff9866d5">AppendTo</a> (Container &amp;container) const</td></tr>
<tr class="separator:a7b47ae84869903d1c7e60c2fff9866d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe51f49dc01310e4cb457238b0a2ffe8" id="r_abe51f49dc01310e4cb457238b0a2ffe8"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:abe51f49dc01310e4cb457238b0a2ffe8"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe51f49dc01310e4cb457238b0a2ffe8">To</a> () const</td></tr>
<tr class="separator:abe51f49dc01310e4cb457238b0a2ffe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1043b2a24a4e29dcb30d36b1d414b1d" id="r_aa1043b2a24a4e29dcb30d36b1d414b1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; struct <a class="el" href="structiovec.html">iovec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1043b2a24a4e29dcb30d36b1d414b1d">GetIov</a> () const</td></tr>
<tr class="separator:aa1043b2a24a4e29dcb30d36b1d414b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a210c55ee26805bffbd0f672f7be0" id="r_ade1a210c55ee26805bffbd0f672f7be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade1a210c55ee26805bffbd0f672f7be0">AppendToIov</a> (std::vector&lt; struct <a class="el" href="structiovec.html">iovec</a> &gt; *iov) const</td></tr>
<tr class="separator:ade1a210c55ee26805bffbd0f672f7be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0a26330fc206a4f85b079061731413" id="r_adf0a26330fc206a4f85b079061731413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_fill_iov_result.html">FillIovResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf0a26330fc206a4f85b079061731413">FillIov</a> (struct <a class="el" href="structiovec.html">iovec</a> *iov, size_t len) const</td></tr>
<tr class="separator:adf0a26330fc206a4f85b079061731413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe95dfc5c8c960b180839fe6b0dd56" id="r_aecfe95dfc5c8c960b180839fe6b0dd56"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecfe95dfc5c8c960b180839fe6b0dd56">operator new</a> (size_t size)</td></tr>
<tr class="separator:aecfe95dfc5c8c960b180839fe6b0dd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5974de2f2b4d0e99a1dbdd1272097b21" id="r_a5974de2f2b4d0e99a1dbdd1272097b21"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5974de2f2b4d0e99a1dbdd1272097b21">operator new</a> (size_t size, void *ptr)</td></tr>
<tr class="separator:a5974de2f2b4d0e99a1dbdd1272097b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829520f671679944efa49a7cc5e5825e" id="r_a829520f671679944efa49a7cc5e5825e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a829520f671679944efa49a7cc5e5825e">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a829520f671679944efa49a7cc5e5825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5245be1b4fc1fa9382af992ad44d0467" id="r_a5245be1b4fc1fa9382af992ad44d0467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5245be1b4fc1fa9382af992ad44d0467">operator delete</a> (void *ptr, void *placement)</td></tr>
<tr class="separator:a5245be1b4fc1fa9382af992ad44d0467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0fb2a8cb526cd819bdc625310cac6f" id="r_a4e0fb2a8cb526cd819bdc625310cac6f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e0fb2a8cb526cd819bdc625310cac6f">MoveToFbString</a> ()</td></tr>
<tr class="separator:a4e0fb2a8cb526cd819bdc625310cac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22211b3c6c1c99872f05ed23e55d138" id="r_ad22211b3c6c1c99872f05ed23e55d138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22211b3c6c1c99872f05ed23e55d138">cbegin</a> () const</td></tr>
<tr class="separator:ad22211b3c6c1c99872f05ed23e55d138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815f1a7b3d0014fb9cd2c7e20a2fcd42" id="r_a815f1a7b3d0014fb9cd2c7e20a2fcd42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a815f1a7b3d0014fb9cd2c7e20a2fcd42">cend</a> () const</td></tr>
<tr class="separator:a815f1a7b3d0014fb9cd2c7e20a2fcd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9acb767b93f0efd67990f4a4351a223" id="r_af9acb767b93f0efd67990f4a4351a223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9acb767b93f0efd67990f4a4351a223">begin</a> () const</td></tr>
<tr class="separator:af9acb767b93f0efd67990f4a4351a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad096f4cf2aaac5ee522618ad6dbe9cbc" id="r_ad096f4cf2aaac5ee522618ad6dbe9cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad096f4cf2aaac5ee522618ad6dbe9cbc">end</a> () const</td></tr>
<tr class="separator:ad096f4cf2aaac5ee522618ad6dbe9cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8e0900f4f9d06d41fa4e7c083217c6a5" id="r_a8e0900f4f9d06d41fa4e7c083217c6a5"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0900f4f9d06d41fa4e7c083217c6a5">Create</a> (std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>)</td></tr>
<tr class="separator:a8e0900f4f9d06d41fa4e7c083217c6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658b91e57a2ba2db9f44f52754816cd0" id="r_a658b91e57a2ba2db9f44f52754816cd0"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658b91e57a2ba2db9f44f52754816cd0">CreateCombined</a> (std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>)</td></tr>
<tr class="separator:a658b91e57a2ba2db9f44f52754816cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e3a9dbf354e19f5a944d98d6c02dff" id="r_a72e3a9dbf354e19f5a944d98d6c02dff"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72e3a9dbf354e19f5a944d98d6c02dff">CreateSeparate</a> (std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>)</td></tr>
<tr class="separator:a72e3a9dbf354e19f5a944d98d6c02dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec83685834b52dc2abb979c60a041f0" id="r_a7ec83685834b52dc2abb979c60a041f0"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ec83685834b52dc2abb979c60a041f0">CreateChain</a> (size_t total_capacity, std::size_t max_buf_capacity)</td></tr>
<tr class="separator:a7ec83685834b52dc2abb979c60a041f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607437c3b69268f69e8f9e1bc91732ba" id="r_a607437c3b69268f69e8f9e1bc91732ba"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer</a> (const void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>)</td></tr>
<tr class="separator:a607437c3b69268f69e8f9e1bc91732ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd25f5c105b84ef5512ac4563b9dc7" id="r_a73bd25f5c105b84ef5512ac4563b9dc7"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73bd25f5c105b84ef5512ac4563b9dc7">WrapBuffer</a> (<a class="el" href="classkiwi_1_1span.html">ByteRange</a> br)</td></tr>
<tr class="separator:a73bd25f5c105b84ef5512ac4563b9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0021793658b0d2bc1b179710296dcb55" id="r_a0021793658b0d2bc1b179710296dcb55"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0021793658b0d2bc1b179710296dcb55">TakeOwnership</a> (void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:a0021793658b0d2bc1b179710296dcb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4997f43bc6a4087debc998829057614" id="r_aa4997f43bc6a4087debc998829057614"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4997f43bc6a4087debc998829057614">TakeOwnership</a> (void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>, std::size_t length, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:aa4997f43bc6a4087debc998829057614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc3d9fb02f907170cf4d0dd956bdb2" id="r_aa3bc3d9fb02f907170cf4d0dd956bdb2"><td class="memTemplParams" colspan="2">template&lt;typename UniquePtr&gt; </td></tr>
<tr class="memitem:aa3bc3d9fb02f907170cf4d0dd956bdb2"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="structkiwi_1_1detail_1_1_is_unique_ptr_to_s_l.html">detail::IsUniquePtrToSL</a>&lt; UniquePtr &gt;::value, std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa3bc3d9fb02f907170cf4d0dd956bdb2">TakeOwnership</a> (UniquePtr &amp;&amp;buf, size_t count=1)</td></tr>
<tr class="separator:aa3bc3d9fb02f907170cf4d0dd956bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8d5735bb6eaf1b4560c884068313c" id="r_abdc8d5735bb6eaf1b4560c884068313c"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc8d5735bb6eaf1b4560c884068313c">WrapIov</a> (const <a class="el" href="structiovec.html">iovec</a> *vec, size_t count)</td></tr>
<tr class="separator:abdc8d5735bb6eaf1b4560c884068313c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0208699d0a3c686e028a160205ed226a" id="r_a0208699d0a3c686e028a160205ed226a"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0208699d0a3c686e028a160205ed226a">TakeOwnershipIov</a> (const <a class="el" href="structiovec.html">iovec</a> *vec, size_t count, FreeFunction free_fn=nullptr, void *user_data=nullptr, bool free_on_error=true)</td></tr>
<tr class="separator:a0208699d0a3c686e028a160205ed226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64afb5aeb32475087026e7fa44ef37e8" id="r_a64afb5aeb32475087026e7fa44ef37e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64afb5aeb32475087026e7fa44ef37e8">WrapBufferAsValue</a> (const void *buf, std::size_t <a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity</a>) noexcept</td></tr>
<tr class="separator:a64afb5aeb32475087026e7fa44ef37e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb99bd7abf8d1b185d4fe18a80c44ad" id="r_a5bb99bd7abf8d1b185d4fe18a80c44ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bb99bd7abf8d1b185d4fe18a80c44ad">WrapBufferAsValue</a> (<a class="el" href="classkiwi_1_1span.html">ByteRange</a> br) noexcept</td></tr>
<tr class="separator:a5bb99bd7abf8d1b185d4fe18a80c44ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ba80c7ca24ab312bfca2816e184bb" id="r_a5c9ba80c7ca24ab312bfca2816e184bb"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c9ba80c7ca24ab312bfca2816e184bb">CopyBuffer</a> (<a class="el" href="classkiwi_1_1span.html">ByteRange</a> br, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:a5c9ba80c7ca24ab312bfca2816e184bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b2f724c2d19eec61729a7de6ade917" id="r_a01b2f724c2d19eec61729a7de6ade917"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b2f724c2d19eec61729a7de6ade917">CopyBuffer</a> (const void *buf, std::size_t size, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:a01b2f724c2d19eec61729a7de6ade917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d236b4584e8a4d1188135c103bf71" id="r_adc5d236b4584e8a4d1188135c103bf71"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc5d236b4584e8a4d1188135c103bf71">CopyBuffer</a> (std::string_view buf, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:adc5d236b4584e8a4d1188135c103bf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb72bf084625127b80ca48d1d2b404d" id="r_a3cb72bf084625127b80ca48d1d2b404d"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cb72bf084625127b80ca48d1d2b404d">MaybeCopyBuffer</a> (std::string_view buf, std::size_t head_room=0, std::size_t min_tail_room=0)</td></tr>
<tr class="separator:a3cb72bf084625127b80ca48d1d2b404d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98078164d255f6b0773220e8dd498949" id="r_a98078164d255f6b0773220e8dd498949"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98078164d255f6b0773220e8dd498949">Destroy</a> (std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;<a class="el" href="#a708944d0de466a93fda5102be9ceb938">data</a>)</td></tr>
<tr class="separator:a98078164d255f6b0773220e8dd498949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9df58e871c20f07b24ad6bb9ee5215d" id="r_af9df58e871c20f07b24ad6bb9ee5215d"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9df58e871c20f07b24ad6bb9ee5215d">GoodSize</a> (size_t min_capacity, CombinedOption combined=CombinedOption::kDefault)</td></tr>
<tr class="separator:af9df58e871c20f07b24ad6bb9ee5215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> manages heap-allocated byte buffers.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
API Details</h2>
<ul>
<li>The buffer is not neccesarily full of meaningful bytes - there may be uninitialized bytes before and after the central "valid" range of data.</li>
<li>Buffers are refcounted, and can be shared by multiple <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects.<ul>
<li>If you ever write to an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, first use <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> to get a unique copy.</li>
</ul>
</li>
<li>IOBufs can be "chained" in a circularly linked list.<ul>
<li>Use <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a> to turn an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</li>
</ul>
</li>
<li>IOBufs are not synchronized. The user is responsible for synchronization. Notes:<ul>
<li>Like a shared_ptr, the refcounting is atomic.</li>
<li>const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> methods do not mutate any state, so can safely be called concurrently with each other, as expected.</li>
</ul>
</li>
<li>IOBufs are typically stored on the heap, so that they can be used in chains.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Data Layout</h2>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects contains a pointer to the buffer and information about which segment of the buffer contains valid data. </p><pre class="fragment"> +-------+
 | IOBuf |
 +-------+
  /
 |            |----- Length() -----|
 v
 +------------+--------------------+-----------+
 | headroom   |        data        |  tailroom |
 +------------+--------------------+-----------+
 ^            ^                    ^           ^
 Buffer()   data()               Tail()      BufferEnd()

 |----------------- capacity() ----------------|
</pre><h2><a class="anchor" id="autotoc_md2"></a>
Buffer Sharing</h2>
<p>Each buffer is reference counted, and multiple <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects may point to the same buffer. Each <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> may point to a different section of valid data within the underlying buffer. For example, if multiple protocol requests are read from the network into a single buffer, a separate <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> may be created for each request, all sharing the same underlying buffer.</p>
<p>In other words, when multiple IOBufs share the same underlying buffer, the <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> and <a class="el" href="#a27b29fcaa18008ff3ba19d93303a4082">Tail()</a> methods on each <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> may point to a different segment of the data. However, the <a class="el" href="#a679f13d5591ed0e4963eb9cc078e9486">Buffer()</a> and <a class="el" href="#a98b138b44fdf260ac04ad2c3f35a3f2f">BufferEnd()</a> methods will point to the same location for all IOBufs sharing the same underlying buffer, unless the tail was trimmed with <a class="el" href="#ab4c768ff0dfc147881a75afc1fe403ea">TrimWritableTail()</a>.</p>
<pre class="fragment">      +-----------+     +---------+
      |  IOBuf 1  |     | IOBuf 2 |
      +-----------+     +---------+
       |         | _____/        |
  data |    tail |/    data      | tail
       v         v               v
 +-------------------------------------+
 |     |         |               |     |
 +-------------------------------------+
</pre><p>If you only read data from an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, you don't need to worry about other <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects possibly sharing the same underlying buffer. However, if you ever write to the buffer you need to first ensure that no other IOBufs point to the same buffer. The <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> method may be used to ensure that you have an unshared buffer.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
IOBuf Chains</h2>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects also contain pointers to next and previous <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects. This can be used to represent a single logical piece of data that is stored in non-contiguous chunks in separate buffers. </p><pre class="fragment">+---------------------------------------------------------------+
|                                                               |
|    +-----------+        +-----------+        +-----------+    |
+--&gt; |  IOBuf 1  | -----&gt; |  IOBuf 2  | -----&gt; |  IOBuf 3  | ---+
     +-----------+        +-----------+        +-----------+
       |        | _________/     |           ___/        \__
       |        |/               |          /               \
       v        v                v         v                 v
 +-------------------------------------+   +-----------------+
 |     |        |                |     |   |                 |
 +-------------------------------------+   +-----------------+
</pre><p>A single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object can only belong to one chain at a time.</p>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chains are always circular. The "prev" pointer in the head of the chain points to the tail of the chain. However, it is up to the user to decide which <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is the head. Internally the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> code does not care which element is the head.</p>
<p>The lifetime of all IOBufs in the chain are linked: when one element in the chain is deleted, all other chained elements are also deleted. Conceptually it is simplest to treat this as if the head of the chain owns all other IOBufs in the chain. When you delete the head of the chain, it will delete the other elements as well. For this reason, <a class="el" href="#a21785f202ca90b05faa6d4b9483c2206">AppendToChain()</a> and <a class="el" href="#a39cce2803d306fcb964a3087b8a030e7">InsertAfterThisOne()</a> take ownership of the new elements being added to this chain.</p>
<p>When the <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a> method is used to coalesce an entire <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, all other IOBufs in the chain are eliminated and automatically deleted. The <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> method may coalesce the chain; if it does it will similarly delete all IOBufs eliminated from the chain.</p>
<p>As discussed in the following section, it is up to the user to maintain a lock around the entire <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain if multiple threads need to access the chain. <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> does not provide any internal locking.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Synchronization</h2>
<p>When used in multithread programs, a single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object should only be accessed mutably by a single thread at a time. All const member functions of <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> are safe to call concurrently with one another, but when a caller uses a single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> across multiple threads and at least one thread calls a non-const member function, the caller is responsible for using an external lock to synchronize access to the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Two separate <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects may be accessed concurrently in separate threads without locking, even if they point to the same underlying buffer. The buffer reference count is always accessed atomically, and no other operations should affect other IOBufs that point to the same data segment. The caller is responsible for using <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> to ensure that the data buffer is not shared by other IOBufs before writing to it, and this ensures that the data itself is not modified in one thread while also being accessed from another thread.</p>
<p>For <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chains, no two IOBufs in the same chain should be accessed simultaneously in separate threads, except where all simultaneous accesses are to const member functions. The caller must maintain a lock around the entire chain if the chain, or individual IOBufs in the chain, may be accessed by multiple threads with at least one of the threads needing to mutate.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
IOBuf Object Allocation</h2>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects themselves exist separately from the data buffer they point to. Therefore one must also consider how to allocate and manage the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects. Typically, IOBufs are allocated on the heap. </p><pre class="fragment"> +--------------+
 |  unique_ptr  |
 +--------------+
   |
   v
 +---------+
 |  IOBuf  |
 +---------+
   |
   v
 +----------+
 |  buffer  |
 +----------+
</pre><p>It is more common to allocate <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects on the heap, using the <a class="el" href="#a8e0900f4f9d06d41fa4e7c083217c6a5">Create()</a>, TakeOwnership(), or <a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer()</a> factory functions. The <a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>/CloneOne() functions also return new heap-allocated IOBufs. The <a class="el" href="#a658b91e57a2ba2db9f44f52754816cd0">CreateCombined()</a> function allocates the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object and data storage space together, in a single memory allocation. This can improve performance, particularly if you know that the data buffer and the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> itself will have similar lifetimes.</p>
<p>That said, it is also possible to allocate IOBufs on the stack or inline inside another object as well. This is useful for cases where the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is short-lived, or when the overhead of allocating the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> on the heap is undesirable.</p>
<p>However, note that stack-allocated IOBufs may only be used as the head of a chain (or standalone as the only <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in a chain). All non-head members of an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain must be heap allocated. (All functions to add nodes to a chain require a std::unique_ptr&lt;IOBuf&gt;, which enforces this requirement.)</p>
<p>Copying IOBufs is only meaningful for the head of a chain. The entire chain is cloned; the IOBufs will become shared, and the old and new IOBufs will refer to the same underlying memory.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
IOBuf Sharing</h2>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> class manages sharing of the underlying buffer that it points to, maintaining a reference count if multiple IOBufs are pointing at the same buffer.</p>
<p>However, it is the callers responsibility to manage sharing and ownership of <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects themselves. The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> structure does not provide room for an intrusive refcount on the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object itself, only the underlying data buffer is reference counted. If users want to share the same <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object between multiple parts of the code, they are responsible for managing this sharing on their own. (For example, by using a shared_ptr. Alternatively, users always have the option of using clone() to create a second <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> that points to the same underlying buffer.)</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Inspiration</h2>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects are intended to be used primarily for networking code, and are modelled somewhat after FreeBSD's mbuf data structure, and Linux's sk_buff structure.</p>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects facilitate zero-copy network programming, by allowing multiple <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects to point to the same underlying buffer of data, using a reference count to track when the buffer is no longer needed and can be freed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f6071e9f9d7fd8f11da8755f5809705" name="a7f6071e9f9d7fd8f11da8755f5809705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6071e9f9d7fd8f11da8755f5809705">&#9670;&#160;</a></span>IOBuf() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">CreateOp</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> with the requested capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to the start of the buffer. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == 0 </dd>
<dd>
<a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity()</a> &gt;= capacity (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9df58e871c20f07b24ad6bb9ee5215d">GoodSize</a> for details on why <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> sometimes allocates a larger buffer than requested)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on malloc failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0da85cf118a667a0f9267bd3e580c95c" name="a0da85cf118a667a0f9267bd3e580c95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da85cf118a667a0f9267bd3e580c95c">&#9670;&#160;</a></span>IOBuf() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">TakeOwnershipOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases. </dd></dl>

</div>
</div>
<a id="a99e9c470caa96aec01ba4c5a0880d8c1" name="a99e9c470caa96aec01ba4c5a0880d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e9c470caa96aec01ba4c5a0880d8c1">&#9670;&#160;</a></span>IOBuf() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">TakeOwnershipOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases.    </dd></dl>

</div>
</div>
<a id="a0ee035419221d92a93e6658bc5520803" name="a0ee035419221d92a93e6658bc5520803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee035419221d92a93e6658bc5520803">&#9670;&#160;</a></span>IOBuf() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">TakeOwnershipOp</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases.    </dd></dl>

</div>
</div>
<a id="a5df8c49db49fbda48c89bf51bd328e82" name="a5df8c49db49fbda48c89bf51bd328e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df8c49db49fbda48c89bf51bd328e82">&#9670;&#160;</a></span>IOBuf() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">TakeOwnershipOp</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizedFree</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases.    </dd></dl>

</div>
</div>
<a id="a2b84f84ca1454238aa2531223d420a78" name="a2b84f84ca1454238aa2531223d420a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b84f84ca1454238aa2531223d420a78">&#9670;&#160;</a></span>IOBuf() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new null buffer.</p>
<p>This can be used to allocate an empty <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> on the stack. It will have no space allocated for it. This is generally useful only to later use move assignment to fill out the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. </p>

</div>
</div>
<a id="a21ca1a066836e9b3b5d8f326851ba487" name="a21ca1a066836e9b3b5d8f326851ba487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca1a066836e9b3b5d8f326851ba487">&#9670;&#160;</a></span>IOBuf() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac0f7ae7b52fbea81b71d468e67cc7cd2">CloneAsValue()</a> </dd></dl>

</div>
</div>
<a id="a23324e396a3a95880e9897f9286c0731" name="a23324e396a3a95880e9897f9286c0731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23324e396a3a95880e9897f9286c0731">&#9670;&#160;</a></span>IOBuf() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<p>In general, you should only ever move the head of an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. Internal nodes in an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain are owned by the head of the chain, and should not be moved from. (Technically, nothing prevents you from moving a non-head node, but the moved-to node will replace the moved-from node in the chain. This has implications for ownership, since non-head nodes are owned by the chain head. You are then responsible for relinquishing ownership of the moved-to node, and manually deleting the moved-from node.) </p>

</div>
</div>
<a id="ac00383234824ff95f192e09d8d77b0c6" name="ac00383234824ff95f192e09d8d77b0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00383234824ff95f192e09d8d77b0c6">&#9670;&#160;</a></span>IOBuf() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">WrapBufferOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1span.html">ByteRange</a></td>          <td class="paramname"><span class="paramname"><em>br</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to a buffer, without taking ownership.</p>
<p>This should only be used when the caller knows the lifetime of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object ahead of time and can ensure that all <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects that will point to this buffer will be destroyed before the buffer itself is destroyed. The buffer will not be freed automatically when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> referencing it is destroyed. It is the caller's responsibility to free the buffer after the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> has been destroyed.</p>
<p>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> created using <a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer()</a> will always be reported as shared. <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> may be used to create a writable copy of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange instead of {buf, capacity}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == capacity. </dd></dl>

</div>
</div>
<a id="af8145236efb0eb62fd99871e94e0d49d" name="af8145236efb0eb62fd99871e94e0d49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8145236efb0eb62fd99871e94e0d49d">&#9670;&#160;</a></span>IOBuf() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">WrapBufferOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to a buffer, without taking ownership.</p>
<p>This should only be used when the caller knows the lifetime of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object ahead of time and can ensure that all <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects that will point to this buffer will be destroyed before the buffer itself is destroyed. The buffer will not be freed automatically when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> referencing it is destroyed. It is the caller's responsibility to free the buffer after the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> has been destroyed.</p>
<p>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> created using <a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer()</a> will always be reported as shared. <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> may be used to create a writable copy of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange instead of {buf, capacity}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == capacity.    </dd></dl>

</div>
</div>
<a id="a39d432d9c1571f0edef9627ca515f87f" name="a39d432d9c1571f0edef9627ca515f87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d432d9c1571f0edef9627ca515f87f">&#9670;&#160;</a></span>IOBuf() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">CopyBufferOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1span.html">ByteRange</a></td>          <td class="paramname"><span class="paramname"><em>br</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cde7c357d8a93da6e41da0231a3c69f" name="a5cde7c357d8a93da6e41da0231a3c69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cde7c357d8a93da6e41da0231a3c69f">&#9670;&#160;</a></span>IOBuf() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::IOBuf </td>
          <td>(</td>
          <td class="paramtype">CopyBufferOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error    </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addcdd5cd5f46ee3a9e6904dd68209b29" name="addcdd5cd5f46ee3a9e6904dd68209b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcdd5cd5f46ee3a9e6904dd68209b29">&#9670;&#160;</a></span>~IOBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kiwi::IOBuf::~IOBuf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Deleting an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will automatically destroy all IOBufs in the chain. (All subsequent IOBufs in the chain are considered to be owned by the head of the chain. Users should only explicitly delete the head of a chain.)</p>
<p>When each individual <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is destroyed, it will release its reference count on the underlying buffer. If it was the last user of the buffer, the buffer will be freed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff66dd7c31c9340d6b9a64b4026d1b5f" name="aff66dd7c31c9340d6b9a64b4026d1b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff66dd7c31c9340d6b9a64b4026d1b5f">&#9670;&#160;</a></span>Advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::Advance </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift the data forwards in the buffer.</p>
<p>This shifts the data pointer forwards in the buffer to increase the headroom. This is commonly used to increase the headroom in a newly allocated buffer.</p>
<p>The caller is responsible for ensuring that there is sufficient tailroom in the buffer before calling advance().</p>
<p>If there is a non-zero data length, advance() will use memmove() to shift the data forwards in the buffer. In this case, the caller is responsible for making sure the buffer is unshared, so it will not affect other IOBufs that may be sharing the same underlying buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift all data forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is unchanged.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="a984449ddf4541eca038b1b4f7b93dd97" name="a984449ddf4541eca038b1b4f7b93dd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984449ddf4541eca038b1b4f7b93dd97">&#9670;&#160;</a></span>Append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::Append </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the tail pointer to include more valid data at the end.</p>
<p>This moves the tail pointer forwards to include more of the available buffer. The caller is responsible for ensuring that there is sufficient tailroom for the new data. The caller is also responsible for populating this section with valid data.</p>
<p>This does not modify any actual data in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift the tail() pointer forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is increased by amount.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="a7feebf266b48e22f583c927a86a98cd0" name="a7feebf266b48e22f583c927a86a98cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feebf266b48e22f583c927a86a98cd0">&#9670;&#160;</a></span>AppendChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::AppendChain </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>iobuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated name for insertAfterThisOne()</p>
<p>Beware: appendToChain() and appendChain() are two different methods, and you probably want appendToChain() instead of this one.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a459ea5071c51a5015b35dafeae183ff0" name="a459ea5071c51a5015b35dafeae183ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459ea5071c51a5015b35dafeae183ff0">&#9670;&#160;</a></span>AppendSharedInfoObserver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Observer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::AppendSharedInfoObserver </td>
          <td>(</td>
          <td class="paramtype">Observer &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>observer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an Observer to the refcount block (SharedInfo).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>The observer to add to SharedInfo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the observer was added (if there is no SharedInfo, there's nothing to observe)</dd></dl>
<p>\methodset Misc </p>

</div>
</div>
<a id="a7b47ae84869903d1c7e60c2fff9866d5" name="a7b47ae84869903d1c7e60c2fff9866d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b47ae84869903d1c7e60c2fff9866d5">&#9670;&#160;</a></span>AppendTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::AppendTo </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append the chain data into the provided container.</p>
<p>This is meant to be used with containers such as std::string or std::vector&lt;char&gt;, but any container which supports <a class="el" href="#a6e23d4cbb808550af93558459aaa092d">reserve()</a>, insert(), and has char or unsigned char value type is supported.</p>
<p>\methodset Conversions </p>

</div>
</div>
<a id="a21785f202ca90b05faa6d4b9483c2206" name="a21785f202ca90b05faa6d4b9483c2206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21785f202ca90b05faa6d4b9483c2206">&#9670;&#160;</a></span>AppendToChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::AppendToChain </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>iobuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append another <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain to the end of this chain.</p>
<p>For example, if there are two <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chains (A, B, C) and (D, E, F), and A-&gt;appendToChain(D) is called, the (D, E, F) chain will be subsumed and become part of the chain starting at A, which will now look like (A, B, C, D, E, F).</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="ade1a210c55ee26805bffbd0f672f7be0" name="ade1a210c55ee26805bffbd0f672f7be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a210c55ee26805bffbd0f672f7be0">&#9670;&#160;</a></span>AppendToIov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::AppendToIov </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; struct <a class="el" href="structiovec.html">iovec</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>iov</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update an existing iovec array with the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> data.</p>
<p>New iovecs will be appended to the existing vector; anything already present in the vector will be left unchanged.</p>
<p>Naturally, the returned iovec data will be invalid if you modify the buffer chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">iov</td><td>The iovector to append to.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset IOV </p>

</div>
</div>
<a id="af155b2c4fc618c19a2fea14c6d5e6e8e" name="af155b2c4fc618c19a2fea14c6d5e6e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af155b2c4fc618c19a2fea14c6d5e6e8e">&#9670;&#160;</a></span>ApproximateShareCountOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kiwi::IOBuf::ApproximateShareCountOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inconsistently get the reference count.</p>
<p>For most of the use-cases where it seems like a good idea to call this function, what you really want is isSharedOne().</p>
<p>If this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is managed by the usual refcounting mechanism (ie isManagedOne() returns true) then this returns the reference count as it was when recently observed by this thread.</p>
<p>If this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is <em>not</em> managed by the usual refcounting mechanism then the result of this function is not defined.</p>
<p>This only checks the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, and not other IOBufs in the chain.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="af9acb767b93f0efd67990f4a4351a223" name="af9acb767b93f0efd67990f4a4351a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9acb767b93f0efd67990f4a4351a223">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">IOBuf::Iterator</a> kiwi::IOBuf::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Iterate over the IOBufs in this chain.</p>
<p>The iterators dereference to a ByteRange.</p>
<p>\methodset Iterators    </p>

</div>
</div>
<a id="a679f13d5591ed0e4963eb9cc078e9486" name="a679f13d5591ed0e4963eb9cc078e9486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679f13d5591ed0e4963eb9cc078e9486">&#9670;&#160;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * kiwi::IOBuf::Buffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the pointer to the start of the buffer.</p>
<p>Note that this is the pointer to the very beginning of the usable buffer, not the start of valid data within the buffer. Use the <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> method to get a pointer to the start of the data within the buffer.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a98b138b44fdf260ac04ad2c3f35a3f2f" name="a98b138b44fdf260ac04ad2c3f35a3f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b138b44fdf260ac04ad2c3f35a3f2f">&#9670;&#160;</a></span>BufferEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * kiwi::IOBuf::BufferEnd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the pointer to the end of the buffer.</p>
<p>Note that this is the pointer to the very end of the usable buffer, not the end of valid data within the buffer. Use the tail() method to get a pointer to the end of the data within the buffer.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a6adefcda03cb041c68d4341ef4eec966" name="a6adefcda03cb041c68d4341ef4eec966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adefcda03cb041c68d4341ef4eec966">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the total size of the buffer.</p>
<p>This returns the total usable length of the buffer. Use the length() method to get the length of the actual valid data in this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>\methodset Buffer Capacity </p>

</div>
</div>
<a id="ad22211b3c6c1c99872f05ed23e55d138" name="ad22211b3c6c1c99872f05ed23e55d138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22211b3c6c1c99872f05ed23e55d138">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">IOBuf::Iterator</a> kiwi::IOBuf::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the IOBufs in this chain.</p>
<p>The iterators dereference to a ByteRange.</p>
<p>\methodset Iterators </p>

</div>
</div>
<a id="a815f1a7b3d0014fb9cd2c7e20a2fcd42" name="a815f1a7b3d0014fb9cd2c7e20a2fcd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815f1a7b3d0014fb9cd2c7e20a2fcd42">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">IOBuf::Iterator</a> kiwi::IOBuf::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Iterate over the IOBufs in this chain.</p>
<p>The iterators dereference to a ByteRange.</p>
<p>\methodset Iterators    </p>

</div>
</div>
<a id="a840a75e5d2f1cc2fb467260fda98ea52" name="a840a75e5d2f1cc2fb467260fda98ea52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840a75e5d2f1cc2fb467260fda98ea52">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the buffer.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> == <a class="el" href="#a679f13d5591ed0e4963eb9cc078e9486">Buffer()</a>. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == 0. </dd></dl>

</div>
</div>
<a id="a441bac0ab805e616558127ff37208d76" name="a441bac0ab805e616558127ff37208d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441bac0ab805e616558127ff37208d76">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<p>This is a shallow buffer copy; the source buffers will be shared.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will normally point to the same underlying data buffers as the original chain. (The one exception to this is if some of the IOBufs in this chain contain small internal data buffers which cannot be shared.)</p>
<p>\methodset Makers </p>

</div>
</div>
<a id="ac0f7ae7b52fbea81b71d468e67cc7cd2" name="ac0f7ae7b52fbea81b71d468e67cc7cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f7ae7b52fbea81b71d468e67cc7cd2">&#9670;&#160;</a></span>CloneAsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::CloneAsValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<p>This is a shallow buffer copy; the source buffers will be shared.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will normally point to the same underlying data buffers as the original chain. (The one exception to this is if some of the IOBufs in this chain contain small internal data buffers which cannot be shared.)</p>
<p>\methodset Makers   </p>
<p>Similar to <a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>, but returns by value rather than heap-allocating. </p>

</div>
</div>
<a id="a77b1abe3f7e7b593375a4a3bc9e61883" name="a77b1abe3f7e7b593375a4a3bc9e61883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b1abe3f7e7b593375a4a3bc9e61883">&#9670;&#160;</a></span>CloneCoalesced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CloneCoalesced </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single buffer.</p>
<p>Semantically similar to .<a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>.<a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>, but without the intermediate allocations.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> for which <a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained()</a> == false, and whose data is the same as <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset Makers </p>

</div>
</div>
<a id="acc296707072f0b490a1508e6e65de8ac" name="acc296707072f0b490a1508e6e65de8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc296707072f0b490a1508e6e65de8ac">&#9670;&#160;</a></span>CloneCoalescedAsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::CloneCoalescedAsValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single buffer.</p>
<p>Semantically similar to .<a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>.<a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>, but without the intermediate allocations.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> for which <a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained()</a> == false, and whose data is the same as <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset Makers   </p>
<p>Similar to cloneCoalesced(), but returns by value rather than heap-allocating. </p>

</div>
</div>
<a id="a363756c29ae03b864d2daca8c4c0277e" name="a363756c29ae03b864d2daca8c4c0277e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363756c29ae03b864d2daca8c4c0277e">&#9670;&#160;</a></span>CloneCoalescedAsValueWithHeadroomTailroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::CloneCoalescedAsValueWithHeadroomTailroom </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_head_room</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_tail_room</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>cloneCoalescedWithHeadroomTailroom(std::size_t, std::size_t) const</p>
<p>Similar to <a class="el" href="#a304d84443564604c8b79fb2065ee741f">CloneCoalescedWithHeadroomTailroom()</a>, but returns by value rather than heap-allocating. </p>

</div>
</div>
<a id="a304d84443564604c8b79fb2065ee741f" name="a304d84443564604c8b79fb2065ee741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d84443564604c8b79fb2065ee741f">&#9670;&#160;</a></span>CloneCoalescedWithHeadroomTailroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CloneCoalescedWithHeadroomTailroom </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_head_room</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_tail_room</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single buffer.</p>
<p>Semantically similar to .<a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>.<a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>, but without the intermediate allocations.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> for which <a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained()</a> == false, and whose data is the same as <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset Makers   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_head_room</td><td>How much headroom the new coalesced chain should have, instead of mimicking the original headroom. </td></tr>
    <tr><td class="paramname">new_tail_room</td><td>How much tailroom the new coalesced chain should have, instead of mimicking the original tailroom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67aa00c7b4f098ec567446e5f80efc3" name="ae67aa00c7b4f098ec567446e5f80efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67aa00c7b4f098ec567446e5f80efc3">&#9670;&#160;</a></span>CloneInto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::CloneInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Copy an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<p>This is a shallow buffer copy; the source buffers will be shared.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will normally point to the same underlying data buffers as the original chain. (The one exception to this is if some of the IOBufs in this chain contain small internal data buffers which cannot be shared.)</p>
<p>\methodset Makers   </p>
<p>Similar to <a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>, but returns by argument. The argument will become the clone's head. Other nodes in the chain (if any) will be allocated on the heap as usual.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">other</td><td>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to assign the clone to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bb771a8c582355c71472a2bdb36e9e2" name="a4bb771a8c582355c71472a2bdb36e9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb771a8c582355c71472a2bdb36e9e2">&#9670;&#160;</a></span>CloneOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CloneOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an individual <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Only clone the buffer of the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>; ignore chained IOBufs.</p>
<p>\methodset Makers </p>

</div>
</div>
<a id="a54945401269798c696f3f17c43a5d6aa" name="a54945401269798c696f3f17c43a5d6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54945401269798c696f3f17c43a5d6aa">&#9670;&#160;</a></span>CloneOneAsValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::CloneOneAsValue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Copy an individual <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Only clone the buffer of the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>; ignore chained IOBufs.</p>
<p>\methodset Makers   </p>
<p>Similar to <a class="el" href="#a4bb771a8c582355c71472a2bdb36e9e2">CloneOne()</a>, but returns by value rather than heap-allocating. </p>

</div>
</div>
<a id="a55d8e92a27d6269fc75ec508ff9f4239" name="a55d8e92a27d6269fc75ec508ff9f4239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d8e92a27d6269fc75ec508ff9f4239">&#9670;&#160;</a></span>CloneOneInto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::CloneOneInto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Copy an individual <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Only clone the buffer of the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>; ignore chained IOBufs.</p>
<p>\methodset Makers   </p>
<p>Similar to <a class="el" href="#a4bb771a8c582355c71472a2bdb36e9e2">CloneOne()</a>, but returns by argument. The argument will become the clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">other</td><td>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to assign the clone to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc67e55ad77e64bdecd1985c89a1d3f0" name="acc67e55ad77e64bdecd1985c89a1d3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc67e55ad77e64bdecd1985c89a1d3f0">&#9670;&#160;</a></span>Coalesce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1span.html">ByteRange</a> kiwi::IOBuf::Coalesce </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coalesce this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single buffer.</p>
<p>This method moves all of the data in this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single contiguous buffer, if it is not already in one buffer. After <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a> returns, this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will be a chain of length one. Other IOBufs in the chain will be automatically deleted.</p>
<p>After coalescing, the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained()</a> == false</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error. On error the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will be unmodified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ByteRange that points to the now-contiguous buffer <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a></dd></dl>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a330906fb632d710757b90ad5a3c95f67" name="a330906fb632d710757b90ad5a3c95f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330906fb632d710757b90ad5a3c95f67">&#9670;&#160;</a></span>CoalesceWithHeadroomTailroom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1span.html">ByteRange</a> kiwi::IOBuf::CoalesceWithHeadroomTailroom </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_head_room</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>new_tail_room</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Coalesce this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single buffer.</p>
<p>This method moves all of the data in this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain into a single contiguous buffer, if it is not already in one buffer. After <a class="el" href="#acc67e55ad77e64bdecd1985c89a1d3f0">Coalesce()</a> returns, this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will be a chain of length one. Other IOBufs in the chain will be automatically deleted.</p>
<p>After coalescing, the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a327d1deedf8559d086fe372e7de6c753">IsChained()</a> == false</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error. On error the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will be unmodified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ByteRange that points to the now-contiguous buffer <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a></dd></dl>
<p>\methodset Chaining   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_head_room</td><td>How much headroom the new coalesced chain should have, instead of mimicking the original headroom. </td></tr>
    <tr><td class="paramname">new_tail_room</td><td>How much tailroom the new coalesced chain should have, instead of mimicking the original tailroom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc0f7ef8d07332c8518dbe1884357464" name="afc0f7ef8d07332c8518dbe1884357464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0f7ef8d07332c8518dbe1884357464">&#9670;&#160;</a></span>ComputeChainCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::ComputeChainCapacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the capacity all IOBufs in the chain.</p>
<p>Beware that this method has to walk the entire chain.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a78fefcb935fa0e189324e07d03702320" name="a78fefcb935fa0e189324e07d03702320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fefcb935fa0e189324e07d03702320">&#9670;&#160;</a></span>ComputeChainDataLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::ComputeChainDataLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length of all the data in this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<p>Beware that this method has to walk the entire chain.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a5c9ba80c7ca24ab312bfca2816e184bb" name="a5c9ba80c7ca24ab312bfca2816e184bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ba80c7ca24ab312bfca2816e184bb">&#9670;&#160;</a></span>CopyBuffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CopyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1span.html">ByteRange</a></td>          <td class="paramname"><span class="paramname"><em>br</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> @methodset Makers </dd></dl>

</div>
</div>
<a id="a01b2f724c2d19eec61729a7de6ade917" name="a01b2f724c2d19eec61729a7de6ade917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b2f724c2d19eec61729a7de6ade917">&#9670;&#160;</a></span>CopyBuffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CopyBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> @methodset Makers    </dd></dl>

</div>
</div>
<a id="adc5d236b4584e8a4d1188135c103bf71" name="adc5d236b4584e8a4d1188135c103bf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d236b4584e8a4d1188135c103bf71">&#9670;&#160;</a></span>CopyBuffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CopyBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error   </td></tr>
  </table>
  </dd>
</dl>
<p>Beware when attempting to invoke this function with a constant string literal and a headroom argument: you will likely end up invoking CopyBuffer(void* buf, size_t size). </p>

</div>
</div>
<a id="a2fb832f44649118ca6ba0f2d09c4de86" name="a2fb832f44649118ca6ba0f2d09c4de86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb832f44649118ca6ba0f2d09c4de86">&#9670;&#160;</a></span>CountChainElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t kiwi::IOBuf::CountChainElements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of IOBufs in this chain.</p>
<p>Beware that this method has to walk the entire chain. Use isChained() if you just want to check if this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is part of a chain or not.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a8e0900f4f9d06d41fa4e7c083217c6a5" name="a8e0900f4f9d06d41fa4e7c083217c6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0900f4f9d06d41fa4e7c083217c6a5">&#9670;&#160;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::Create </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> with the requested capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to the start of the buffer. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == 0 </dd>
<dd>
<a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity()</a> &gt;= capacity (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9df58e871c20f07b24ad6bb9ee5215d">GoodSize</a> for details on why <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> sometimes allocates a larger buffer than requested)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on malloc failure    </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. \methodset Makers </dd></dl>

</div>
</div>
<a id="a7ec83685834b52dc2abb979c60a041f0" name="a7ec83685834b52dc2abb979c60a041f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec83685834b52dc2abb979c60a041f0">&#9670;&#160;</a></span>CreateChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CreateChain </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>total_capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_buf_capacity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_capacity</td><td>The total buffer size of all IOBufs in the chain </td></tr>
    <tr><td class="paramname">max_buf_capacity</td><td>The maximum buffer size of each <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#afc0f7ef8d07332c8518dbe1884357464">ComputeChainCapacity()</a> &gt;= total_capacity</dd></dl>
<p>Note: Some malloc implementations will internally round up an allocation size to a convenient amount (e.g. jemalloc(31) will actually give you a slab of size 32). Your buffer size could actually be rounded up to <code>GoodMallocSize(max_buf_capacity)</code>.</p>
<p>\methodset Makers </p>

</div>
</div>
<a id="a658b91e57a2ba2db9f44f52754816cd0" name="a658b91e57a2ba2db9f44f52754816cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658b91e57a2ba2db9f44f52754816cd0">&#9670;&#160;</a></span>CreateCombined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CreateCombined </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, allocated alongside its buffer.</p>
<p>This method uses a single memory allocation to allocate space for both the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object and the data storage space. This saves one memory allocation.</p>
<p>This can be wasteful if the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and the buffer have different lifetimes. The memory will not be reclaimed until both objects are destroyed. This can happen, for example, if the buffer is grown using <a class="el" href="#a6e23d4cbb808550af93558459aaa092d">reserve()</a>.</p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> with the requested capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to the start of the buffer. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == 0 </dd>
<dd>
<a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity()</a> &gt;= capacity (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9df58e871c20f07b24ad6bb9ee5215d">GoodSize</a> for details on why <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> sometimes allocates a larger buffer than requested)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on malloc failure    \methodset Makers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72e3a9dbf354e19f5a944d98d6c02dff" name="a72e3a9dbf354e19f5a944d98d6c02dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e3a9dbf354e19f5a944d98d6c02dff">&#9670;&#160;</a></span>CreateSeparate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::CreateSeparate </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, allocated separately from its buffer.</p>
<p><a class="el" href="#a8e0900f4f9d06d41fa4e7c083217c6a5">IOBuf::Create()</a> doesn't necessarily perform separate allocations if the buffer is small. This function forces the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and its buffer to be allocated separately. This can save space if you know that the buffer will be reallocated.</p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> with the requested capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The size of buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to the start of the buffer. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == 0 </dd>
<dd>
<a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity()</a> &gt;= capacity (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af9df58e871c20f07b24ad6bb9ee5215d">GoodSize</a> for details on why <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> sometimes allocates a larger buffer than requested)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on malloc failure    \methodset Makers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708944d0de466a93fda5102be9ceb938" name="a708944d0de466a93fda5102be9ceb938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708944d0de466a93fda5102be9ceb938">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * kiwi::IOBuf::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the pointer to the start of the data.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a98078164d255f6b0773220e8dd498949" name="a98078164d255f6b0773220e8dd498949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98078164d255f6b0773220e8dd498949">&#9670;&#160;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kiwi::IOBuf::Destroy </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Note: as with all <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> destruction, this will also destroy all other IOBufs in the same chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>data will be nullptr.</dd></dl>
<p>\methodset Memory </p>

</div>
</div>
<a id="afa66a4d02d63c3eee6a85ba4a726672b" name="afa66a4d02d63c3eee6a85ba4a726672b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa66a4d02d63c3eee6a85ba4a726672b">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the chain is empty.</p>
<p>This method is semantically equivalent to i-&gt;<a class="el" href="#a78fefcb935fa0e189324e07d03702320">ComputeChainDataLength()</a> == 0 but may run faster because it can short-circuit as soon as it encounters a buffer with <a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> != 0</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="ad096f4cf2aaac5ee522618ad6dbe9cbc" name="ad096f4cf2aaac5ee522618ad6dbe9cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad096f4cf2aaac5ee522618ad6dbe9cbc">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf_1_1_iterator.html">IOBuf::Iterator</a> kiwi::IOBuf::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Iterate over the IOBufs in this chain.</p>
<p>The iterators dereference to a ByteRange.</p>
<p>\methodset Iterators    </p>

</div>
</div>
<a id="adf0a26330fc206a4f85b079061731413" name="adf0a26330fc206a4f85b079061731413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0a26330fc206a4f85b079061731413">&#9670;&#160;</a></span>FillIov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkiwi_1_1_i_o_buf_1_1_fill_iov_result.html">IOBuf::FillIovResult</a> kiwi::IOBuf::FillIov </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structiovec.html">iovec</a> *</td>          <td class="paramname"><span class="paramname"><em>iov</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill an iovec array with the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> data.</p>
<p>Returns a struct with two fields: the number of iovec filled, and total size of the iovecs filled. If there are more buffer than iovec, returns 0 in both fields. This version is suitable to use with stack iovec arrays.</p>
<p>Naturally, the filled iovec data will be invalid if you modify the buffer chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">iov</td><td>The iovector to append to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>The size of the iov array</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset IOV </p>

</div>
</div>
<a id="ad01aa5a69e98470d66c113e8aafb06d1" name="ad01aa5a69e98470d66c113e8aafb06d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01aa5a69e98470d66c113e8aafb06d1">&#9670;&#160;</a></span>Gather()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::Gather </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>contiguous_length</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that this chain has at least contiguousLength bytes available as a contiguous memory range.</p>
<p>This method coalesces whole buffers in the chain into this buffer as necessary until this buffer's length() is at least contiguousLength.</p>
<p>After coalescing, the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have at least as much headroom as the first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain, and at least as much tailroom as the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> that was coalesced.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>or std::overflow_error on error. On error the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will be unmodified. </td></tr>
    <tr><td class="paramname">std::overflow_error</td><td>if contiguousLength is longer than the total chain length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> &gt;= contiguousLength</dd></dl>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a28e1ea256d1bd6bbbdafdea48dfed2eb" name="a28e1ea256d1bd6bbbdafdea48dfed2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e1ea256d1bd6bbbdafdea48dfed2eb">&#9670;&#160;</a></span>GetFreeFn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreeFunction kiwi::IOBuf::GetFreeFn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the FreeFunction.</p>
<p>freeFn is the optional constructor argument which shall be called when the buffer is to be destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>A non-owning pointer to freeFn if set, else nullptr.</dd></dl>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="aa1043b2a24a4e29dcb30d36b1d414b1d" name="aa1043b2a24a4e29dcb30d36b1d414b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1043b2a24a4e29dcb30d36b1d414b1d">&#9670;&#160;</a></span>GetIov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; struct <a class="el" href="structiovec.html">iovec</a> &gt; kiwi::IOBuf::GetIov </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an iovector suitable for e.g. writev().</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> iov = buf-&gt;GetIov();</div>
<div class="line"><span class="keyword">auto</span> xfer = writev(fd, iov.data(), iov.size());</div>
</div><!-- fragment --><p>Naturally, the returned iovector is invalid if you modify the buffer chain.</p>
<p>\methodset IOV </p>

</div>
</div>
<a id="a60bb8092a47d0323280174c78d61c3c2" name="a60bb8092a47d0323280174c78d61c3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bb8092a47d0323280174c78d61c3c2">&#9670;&#160;</a></span>GetUserData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * kiwi::IOBuf::GetUserData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get userData.</p>
<p>userData is the optional constructor argument which will be passed to the FreeFunction.</p>
<dl class="section return"><dt>Returns</dt><dd>A non-owning pointer to userData if set, else nullptr</dd></dl>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="af9df58e871c20f07b24ad6bb9ee5215d" name="af9df58e871c20f07b24ad6bb9ee5215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9df58e871c20f07b24ad6bb9ee5215d">&#9670;&#160;</a></span>GoodSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t kiwi::IOBuf::GoodSize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>min_capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombinedOption</td>          <td class="paramname"><span class="paramname"><em>combined</em></span><span class="paramdefsep"> = </span><span class="paramdefval">CombinedOption::kDefault</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a good malloc size.</p>
<p>Some malloc implementations will internally round up an allocation size to a convenient amount. For example, jemalloc(31) will actually return a buffer of size 32. Instead of wasting such tailroom, use it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_capacity</td><td>The malloc size to round up. </td></tr>
    <tr><td class="paramname">combined</td><td>Here be dragons. T154812262. The default value of DEFAULT is (a) hard to explain, and (b) probably not what you want. Refer to the code to see why.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value at least as large as min_capacity. The overage, if any, depends on the allocator.</dd></dl>
<p>Note that IOBufs do this up-sizing for you: they will round up to the full allocation size and make that capacity available to you without your using this function. This just lets you introspect into that process, so you can for example figure out whether a given <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> can be usefully compacted.</p>
<p>\methodset Memory </p>

</div>
</div>
<a id="a9f9c776ad615d21567b831945c1529d5" name="a9f9c776ad615d21567b831945c1529d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9c776ad615d21567b831945c1529d5">&#9670;&#160;</a></span>HeadRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::HeadRoom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the amount of head room.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the buffer before the start of the data.</dd></dl>
<p>\methodset Buffer Capacity </p>

</div>
</div>
<a id="a39cce2803d306fcb964a3087b8a030e7" name="a39cce2803d306fcb964a3087b8a030e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cce2803d306fcb964a3087b8a030e7">&#9670;&#160;</a></span>InsertAfterThisOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::InsertAfterThisOne </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>iobuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain immediately after this chain element.</p>
<p>For example, if there are two <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chains (A, B, C) and (D, E, F), and B-&gt;insertAfterThisOne(D) is called, the (D, E, F) chain will be subsumed and become part of the chain starting at A, which will now look like (A, B, D, E, F, C)</p>
<p>Note if X is an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain with just a single element, X-&gt;appendToChain() and X-&gt;insertAfterThisOne() behave identically.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a327d1deedf8559d086fe372e7de6c753" name="a327d1deedf8559d086fe372e7de6c753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327d1deedf8559d086fe372e7de6c753">&#9670;&#160;</a></span>IsChained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::IsChained </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> part of a chain.</p>
<p>Technically, all IOBufs are part of a chain, possibly of length 1. This functin checks if the chain is non-trivial, i.e. the chain has more than just one <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in it.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff the the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>'s chain has more than 1 <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in it</dd></dl>
<p>\methodset Chaining </p>

</div>
</div>
<a id="ae206bc7d596ee0679fb459e6f44f2756" name="ae206bc7d596ee0679fb459e6f44f2756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae206bc7d596ee0679fb459e6f44f2756">&#9670;&#160;</a></span>IsManaged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::IsManaged </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if all IOBufs in this chain use the standard refcounting mechanism.</p>
<p>If so, then the lifetime of the underlying memory can be extended by <a class="el" href="#a441bac0ab805e616558127ff37208d76">Clone()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff all IOBufs in this chain are <a class="el" href="#ab044ec809760986f38f05f56048c90ce">IsManagedOne()</a>.</dd></dl>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="ab044ec809760986f38f05f56048c90ce" name="ab044ec809760986f38f05f56048c90ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab044ec809760986f38f05f56048c90ce">&#9670;&#160;</a></span>IsManagedOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::IsManagedOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> uses the standard refcounting mechanism.</p>
<p>If so, then the lifetime of the underlying memory can be extended by <a class="el" href="#a4bb771a8c582355c71472a2bdb36e9e2">CloneOne()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true iff the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> was allocated normally (without the user specifying special memory semantics, such as with a user-owned buffer)</dd></dl>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="ad6d427b0dc2129015373da3e25c52d15" name="ad6d427b0dc2129015373da3e25c52d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d427b0dc2129015373da3e25c52d15">&#9670;&#160;</a></span>IsShared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::IsShared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if any chain buffers are shared.</p>
<p>Return true if at least one of the IOBufs in this chain are shared, or false if all of the IOBufs point to unique buffers.</p>
<p>Use isSharedOne() to only check this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> rather than the entire chain.</p>
<p>If isShared() returns false, then you are probably the sole owner of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain and can write to it without needing to call unshare(). This is not a guarantee, since it is possible for another thread to concurrently acquire shared ownership.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="acfe2272b3bce96c3abb4d0943ef4fc9b" name="acfe2272b3bce96c3abb4d0943ef4fc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2272b3bce96c3abb4d0943ef4fc9b">&#9670;&#160;</a></span>IsSharedOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kiwi::IOBuf::IsSharedOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the buffer is shared.</p>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> buffers can be shared (using refcounting). Check if any other IOBufs are pointing to this same buffer.</p>
<p>If this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> points at a buffer owned by another (non-IOBuf) part of the code (i.e., if the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> was created using wrapBuffer(), or was cloned from such an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>), it is always considered shared.</p>
<p>This only checks the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, and not other IOBufs in the chain.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="a73808ff60c3bdbd250e0a4dbf556dd45" name="a73808ff60c3bdbd250e0a4dbf556dd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73808ff60c3bdbd250e0a4dbf556dd45">&#9670;&#160;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::Length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the size of the data for this individual <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain.</p>
<p>Use <a class="el" href="#a78fefcb935fa0e189324e07d03702320">ComputeChainDataLength()</a> for the sum of data length for the full chain.</p>
<p>@methodset Buffer Capacity </p>

</div>
</div>
<a id="a2c24eab145eaf298ac70d02eee0baa3d" name="a2c24eab145eaf298ac70d02eee0baa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c24eab145eaf298ac70d02eee0baa3d">&#9670;&#160;</a></span>MakeManaged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::MakeManaged </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the buffers are owned by the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain.</p>
<p>It is possible for an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to be constructed with a user-owned buffer. In such circumstances, the user is responsible for ensuring that the buffer outlives the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. <a class="el" href="#a2c24eab145eaf298ac70d02eee0baa3d">MakeManaged()</a> lets the user subsequently reallocate the buffer to be owned by the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> directly.</p>
<p>If the buffers are already owned by <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, then this function doesn't need to do anything.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="a102404f55b2abc56d44bdcd10a5e4f08" name="a102404f55b2abc56d44bdcd10a5e4f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102404f55b2abc56d44bdcd10a5e4f08">&#9670;&#160;</a></span>MakeManagedOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::MakeManagedOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the buffer is owned by the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>It is possible for an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to be constructed with a user-owned buffer. In such circumstances, the user is responsible for ensuring that the buffer outlives the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. <a class="el" href="#a2c24eab145eaf298ac70d02eee0baa3d">MakeManaged()</a> lets the user subsequently reallocate the buffer to be owned by the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> directly.</p>
<p>If the buffer is already owned by <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, then this function doesn't need to do anything.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="aa3d64b8e2e59d867eb7d73db6a0500c3" name="aa3d64b8e2e59d867eb7d73db6a0500c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d64b8e2e59d867eb7d73db6a0500c3">&#9670;&#160;</a></span>MarkExternallyShared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::MarkExternallyShared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the underlying buffers in this chain as shared.</p>
<p>Assume that the underlying buffers are also owned by an external memory management mechanism. This will make <a class="el" href="#ad6d427b0dc2129015373da3e25c52d15">IsShared()</a> always returns true.</p>
<p>This function is not thread-safe, and only safe to call immediately after creating an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, before it has been shared with other threads.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="aca41d072b060f79a73bc3e6b67dca4bb" name="aca41d072b060f79a73bc3e6b67dca4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca41d072b060f79a73bc3e6b67dca4bb">&#9670;&#160;</a></span>MarkExternallySharedOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::MarkExternallySharedOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark the underlying buffer as shared.</p>
<p>Assume that the underlying buffer is also owned by an external memory management mechanism. This will make isSharedOne() always returns true.</p>
<p>This function is not thread-safe, and only safe to call immediately after creating an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>, before it has been shared with other threads.</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="a3cb72bf084625127b80ca48d1d2b404d" name="a3cb72bf084625127b80ca48d1d2b404d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb72bf084625127b80ca48d1d2b404d">&#9670;&#160;</a></span>MaybeCopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::MaybeCopyBuffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>head_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> and copy data into the buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a newly-allocated buffer. That buffer shall be populated with data from the argument buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer from which to copy data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer from which to copy data. </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange in lieu of {buf, size}. </td></tr>
    <tr><td class="paramname">head_room</td><td>The amount of headroom to add to the destination buffer. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The amount of tailroom to add to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to a new buffer whose content is the same as buf </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == size </dd>
<dd>
<a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> == head_room </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error   </td></tr>
  </table>
  </dd>
</dl>
<p>This "maybe" version of copyBuffer returns null if the input is empty.</p>
<p>\methodset Makers </p>

</div>
</div>
<a id="a4e0fb2a8cb526cd819bdc625310cac6f" name="a4e0fb2a8cb526cd819bdc625310cac6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0fb2a8cb526cd819bdc625310cac6f">&#9670;&#160;</a></span>MoveToFbString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string kiwi::IOBuf::MoveToFbString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructively convert to an string.</p>
<p>Destructively convert this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to a string efficiently. We rely on fbstring's <a class="el" href="namespacekiwi.html#a7df83edab5560ff28ed4ebc60cebed70">AcquireMallocatedString</a> constructor to transfer memory.</p>
<p>\methodset Conversions </p>

</div>
</div>
<a id="aea1b72cbad61f1afcc081eaad99590d5" name="aea1b72cbad61f1afcc081eaad99590d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1b72cbad61f1afcc081eaad99590d5">&#9670;&#160;</a></span>Next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> * kiwi::IOBuf::Next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the next <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in this chain.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="aeb8c881127b62ed7370552cba6d1db21" name="aeb8c881127b62ed7370552cba6d1db21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8c881127b62ed7370552cba6d1db21">&#9670;&#160;</a></span>Next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> * kiwi::IOBuf::Next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a829520f671679944efa49a7cc5e5825e" name="a829520f671679944efa49a7cc5e5825e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829520f671679944efa49a7cc5e5825e">&#9670;&#160;</a></span>operator delete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden operator delete. \methodset Memory </p>

</div>
</div>
<a id="a5245be1b4fc1fa9382af992ad44d0467" name="a5245be1b4fc1fa9382af992ad44d0467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5245be1b4fc1fa9382af992ad44d0467">&#9670;&#160;</a></span>operator delete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>placement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden operator delete. \methodset Memory </p>

</div>
</div>
<a id="aecfe95dfc5c8c960b180839fe6b0dd56" name="aecfe95dfc5c8c960b180839fe6b0dd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfe95dfc5c8c960b180839fe6b0dd56">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * kiwi::IOBuf::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden operator new and delete.</p>
<p>These perform specialized memory management to help support <a class="el" href="#a658b91e57a2ba2db9f44f52754816cd0">CreateCombined()</a>, which allocates <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects together with the buffer data.</p>
<p>\methodset Memory </p>

</div>
</div>
<a id="a5974de2f2b4d0e99a1dbdd1272097b21" name="a5974de2f2b4d0e99a1dbdd1272097b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5974de2f2b4d0e99a1dbdd1272097b21">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * kiwi::IOBuf::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden operator new. \methodset Memory </p>

</div>
</div>
<a id="ae17f40ce23314a50600522d1fa78a485" name="ae17f40ce23314a50600522d1fa78a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17f40ce23314a50600522d1fa78a485">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp; kiwi::IOBuf::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment operator.</p>
<p>Move assignment operator.</p>
<p>With the assignment operator, the destination should be the head of an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain or a solitary <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> not part of a chain. If the destination is part of a chain, all other IOBufs in the chain will be deleted.    </p><dl class="section see"><dt>See also</dt><dd>cloneAsValue() </dd></dl>

</div>
</div>
<a id="a3ebf9feefdc07aa06d61ca2c58f81fa4" name="a3ebf9feefdc07aa06d61ca2c58f81fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebf9feefdc07aa06d61ca2c58f81fa4">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp; kiwi::IOBuf::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator.</p>
<p>With the assignment operator, the destination should be the head of an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain or a solitary <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> not part of a chain. If the destination is part of a chain, all other IOBufs in the chain will be deleted. </p>

</div>
</div>
<a id="afc8005e47b46e804cf63c89614a2ff2b" name="afc8005e47b46e804cf63c89614a2ff2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8005e47b46e804cf63c89614a2ff2b">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::pop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the rest of the chain from this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>Ownership of all elements an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain is normally maintained by the head of the chain. <a class="el" href="#afc8005e47b46e804cf63c89614a2ff2b">pop()</a> transfers ownership of the rest of the chain to the caller.</p>
<p>Since <a class="el" href="#afc8005e47b46e804cf63c89614a2ff2b">pop()</a> transfers ownership of the rest to the caller, be careful not to call <a class="el" href="#afc8005e47b46e804cf63c89614a2ff2b">pop()</a> except on the head of a chain.</p>
<dl class="section return"><dt>Returns</dt><dd>A new unique_ptr pointing to the rest of the chain; nullptr if this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> was the only chain element. </dd></dl>

</div>
</div>
<a id="a756590a6a2922b5aa48dc77d45f93405" name="a756590a6a2922b5aa48dc77d45f93405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756590a6a2922b5aa48dc77d45f93405">&#9670;&#160;</a></span>prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::prepend </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the data pointer to include more valid data at the beginning.</p>
<p>This moves the data pointer backwards to include more of the available buffer. The caller is responsible for ensuring that there is sufficient headroom for the new data. The caller is also responsible for populating this section with valid data.</p>
<p>This does not modify any actual data in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift the <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> pointer backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is increased by amount.</dd></dl>
<p>@methodset Shifting </p>

</div>
</div>
<a id="a8c15c5b8a4558580586e7b01940c48d6" name="a8c15c5b8a4558580586e7b01940c48d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c15c5b8a4558580586e7b01940c48d6">&#9670;&#160;</a></span>PrependChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::PrependChain </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>iobuf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated name for appendToChain()</p>
<p><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chains are circular, so appending to the end of the chain is logically equivalent to prepending to the current head (but keeping the chain head pointing to the same element). That was the reason this method was originally called prependChain(). However, almost every time this method is called the intent is to append to the end of a chain, so the <code><a class="el" href="#a8c15c5b8a4558580586e7b01940c48d6">PrependChain()</a></code> name is very confusing to most callers.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a6e6cfe3b15ad1c481d93926b3c0337a4" name="a6e6cfe3b15ad1c481d93926b3c0337a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6cfe3b15ad1c481d93926b3c0337a4">&#9670;&#160;</a></span>Prev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> * kiwi::IOBuf::Prev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the previous <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in this chain.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="ad34fb6470113b215c11dc1b84296ac50" name="ad34fb6470113b215c11dc1b84296ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34fb6470113b215c11dc1b84296ac50">&#9670;&#160;</a></span>Prev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> * kiwi::IOBuf::Prev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a6e23d4cbb808550af93558459aaa092d" name="a6e23d4cbb808550af93558459aaa092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e23d4cbb808550af93558459aaa092d">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_head_room</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_tail_room</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the buffer has enough free space.</p>
<p>Ensure that this buffer has at least minHeadroom headroom bytes and at least minTailroom tailroom bytes. The buffer must be writable (you must call unshare() before this, if necessary).</p>
<p>This might involve a reallocation of the underlying buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_head_room</td><td>The requested amount of headroom. </td></tr>
    <tr><td class="paramname">min_tail_room</td><td>The requested amount of tailroom.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a9f9c776ad615d21567b831945c1529d5">HeadRoom()</a> &gt;= min_head_room. </dd>
<dd>
<a class="el" href="#a23acbdc67f657564e646efe8cd9a6fa3">TailRoom()</a> &gt;= min_tail_room. </dd>
<dd>
The contents between <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> and tail() are preseved.</dd></dl>
<p>\methodset Buffer Capacity </p>

</div>
</div>
<a id="adc048704e057d61e58e09367661d2454" name="adc048704e057d61e58e09367661d2454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc048704e057d61e58e09367661d2454">&#9670;&#160;</a></span>Retreat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::Retreat </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift the data backwards in the buffer.</p>
<p>This shifts the data pointer backwards in the buffer, decreasing the headroom.</p>
<p>The caller is responsible for ensuring that there is sufficient headroom in the buffer before calling retreat().</p>
<p>If there is a non-zero data length, retreat() will use memmove() to shift the data backwards in the buffer. In this case, the caller is responsible for making sure the buffer is unshared, so it will not affect other IOBufs that may be sharing the same underlying buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift all data backward </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is unchanged.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="af3c0af6870164ad98f8470ef984d8fe2" name="af3c0af6870164ad98f8470ef984d8fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c0af6870164ad98f8470ef984d8fe2">&#9670;&#160;</a></span>SeparateChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::SeparateChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> *</td>          <td class="paramname"><span class="paramname"><em>tail</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a subchain from this chain.</p>
<p>Remove the subchain starting at head and ending at tail from this chain. This is inclusive of tail.</p>
<p>If you have a chain (A, B, C, D, E, F), and you call A-&gt;separateChain(B,
D), then you will be returned the chain (B, C, D) and the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will change to (A, E, F).</p>
<p>Returns a unique_ptr pointing to the new head. (In other words, ownership of the head of the subchain is transferred to the caller.) If the caller ignores the return value and lets the unique_ptr be destroyed, the subchain will be immediately destroyed.</p>
<p>head may equal tail. In this case, the subchain of length 1 is removed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>head and tail are part of the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. </dd>
<dd>
head and tail are not equal to the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>The first <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain element to remove. </td></tr>
    <tr><td class="paramname">tail</td><td>The last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain element to remove (inclusive).</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a27b29fcaa18008ff3ba19d93303a4082" name="a27b29fcaa18008ff3ba19d93303a4082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b29fcaa18008ff3ba19d93303a4082">&#9670;&#160;</a></span>Tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * kiwi::IOBuf::Tail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the pointer to the end of the data.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a23acbdc67f657564e646efe8cd9a6fa3" name="a23acbdc67f657564e646efe8cd9a6fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23acbdc67f657564e646efe8cd9a6fa3">&#9670;&#160;</a></span>TailRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t kiwi::IOBuf::TailRoom </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the amount of tail room.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the buffer after the end of the data.</dd></dl>
<p>\methodset Buffer Capacity </p>

</div>
</div>
<a id="aa3bc3d9fb02f907170cf4d0dd956bdb2" name="aa3bc3d9fb02f907170cf4d0dd956bdb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bc3d9fb02f907170cf4d0dd956bdb2">&#9670;&#160;</a></span>TakeOwnership() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UniquePtr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structkiwi_1_1detail_1_1_is_unique_ptr_to_s_l.html">detail::IsUniquePtrToSL</a>&lt; UniquePtr &gt;::value, std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; &gt;::type kiwi::IOBuf::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype">UniquePtr &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> with a reinterpreted buffer.</p>
<p>Create a new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to an existing data buffer made up of count objects of a given standard-layout type.</p>
<p>This is dangerous &ndash; it is essentially equivalent to doing reinterpret_cast&lt;unsigned char*&gt; on your data &ndash; but it's often useful for serialization / deserialization.</p>
<p>The new <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it appropriately (by calling the UniquePtr's custom deleter, or by calling delete or delete[] appropriately if there is no custom deleter) when the buffer is destroyed. The custom deleter, if any, must never throw exceptions.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> data pointer will initially point to the start of the buffer, and the length will be the full capacity of the buffer (count * sizeof(T)).</p>
<p>On error, std::bad_alloc will be thrown, and the buffer will be freed before throwing the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The unique_ptr to the buffer. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. \methodset Makers.</dd></dl>
<p>TODO T154818309 </p>

</div>
</div>
<a id="a0021793658b0d2bc1b179710296dcb55" name="a0021793658b0d2bc1b179710296dcb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0021793658b0d2bc1b179710296dcb55">&#9670;&#160;</a></span>TakeOwnership() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases.    </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. \methodset Makers </dd></dl>

</div>
</div>
<a id="aa4997f43bc6a4087debc998829057614" name="aa4997f43bc6a4087debc998829057614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4997f43bc6a4087debc998829057614">&#9670;&#160;</a></span>TakeOwnership() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> by taking ownership of an existing buffer.</p>
<p>The <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will assume ownership of the buffer, and free it by calling the specified FreeFunction when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to this buffer is destroyed.</p><ul>
<li>The FreeFunction will be called like free_fn(buf, user_data)</li>
<li>free_fn must not throw an exception</li>
<li>If no free_fn is specified, then the buffer will be freed using free(). Note that this is UB if the buffer was allocated using <code>new</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer. </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>The position within the buffer at which the data begins; for overloads without this parameter, it defaults to 0. </td></tr>
    <tr><td class="paramname">length</td><td>The amount of data already in buf; for overloads without this parameter, it defaults to capacity. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception. </td></tr>
    <tr><td class="paramname">SizedFree</td><td>For overloads specified by this enum type, use io_buf_free_cn(buf, capacity) as the free_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf+offset (in overloads without offset, offset defaults to 0) </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == length (in overloads without length, length defaults to capacity)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If length is unspecified, it defaults to capacity, as opposed to empty. </dd>
<dd>
free_on_error is not properly handled in all cases.    </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. \methodset Makers </dd></dl>

</div>
</div>
<a id="a0208699d0a3c686e028a160205ed226a" name="a0208699d0a3c686e028a160205ed226a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0208699d0a3c686e028a160205ed226a">&#9670;&#160;</a></span>TakeOwnershipIov()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::TakeOwnershipIov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structiovec.html">iovec</a> *</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FreeFunction</td>          <td class="paramname"><span class="paramname"><em>free_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>free_on_error</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take ownership of an iovec, turning it into an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>A helper that takes ownerships a number of iovecs into an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. If count == 0, then a zero length buf is returned. This function never returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The iovec array to convert to an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the iovec array. </td></tr>
    <tr><td class="paramname">free_fn</td><td>The function to call when buf is to be freed. </td></tr>
    <tr><td class="paramname">user_data</td><td>An additional arbitrary void* argument to supply to free_fn. </td></tr>
    <tr><td class="paramname">free_on_error</td><td>Whether the buffer should be freed if this function throws an exception.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset IOV </p>

</div>
</div>
<a id="abe51f49dc01310e4cb457238b0a2ffe8" name="abe51f49dc01310e4cb457238b0a2ffe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe51f49dc01310e4cb457238b0a2ffe8">&#9670;&#160;</a></span>To()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container kiwi::IOBuf::To </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the chain data into a container.</p>
<p>Append the chain data into the provided container.</p>
<p>This is meant to be used with containers such as std::string or std::vector&lt;char&gt;, but any container which supports <a class="el" href="#a6e23d4cbb808550af93558459aaa092d">reserve()</a>, insert(), and has char or unsigned char value type is supported.</p>
<p>\methodset Conversions   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of container to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Container whose data equals the coalseced data of this chain. </dd></dl>

</div>
</div>
<a id="adb54ae0c205585a88308117dd3e8354e" name="adb54ae0c205585a88308117dd3e8354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54ae0c205585a88308117dd3e8354e">&#9670;&#160;</a></span>TrimEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::TrimEnd </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the tail pointer backwards to include less valid data.</p>
<p>This moves the tail pointer backwards so that the last amount bytes are no longer considered valid data. The caller is responsible for ensuring that amount is less than or equal to the actual data length.</p>
<p>This does not modify any actual data in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift the tail() pointer backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is decreased by amount.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="ab3d9b6d522b325ff3d8ba04dcafe3203" name="ab3d9b6d522b325ff3d8ba04dcafe3203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d9b6d522b325ff3d8ba04dcafe3203">&#9670;&#160;</a></span>TrimStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::TrimStart </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the data pointer to include less valid data.</p>
<p>This moves the data pointer forwards so that the first amount bytes are no longer considered valid data. The caller is responsible for ensuring that amount is less than or equal to the actual data length.</p>
<p>This does not modify any actual data in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift the <a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> pointer forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> is decreased by amount.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="ab4c768ff0dfc147881a75afc1fe403ea" name="ab4c768ff0dfc147881a75afc1fe403ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c768ff0dfc147881a75afc1fe403ea">&#9670;&#160;</a></span>TrimWritableTail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::TrimWritableTail </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>amount</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the buffer end pointer to reduce the buffer capacity.</p>
<p>This can be used to pass the ownership of the writable tail to another <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The amount by which to shift the bufferEnd() pointer backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a6adefcda03cb041c68d4341ef4eec966">capacity()</a> is decreased by amount.</dd></dl>
<p>\methodset Shifting </p>

</div>
</div>
<a id="a45cd21c00ea100c65d0a01fb07d70303" name="a45cd21c00ea100c65d0a01fb07d70303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cd21c00ea100c65d0a01fb07d70303">&#9670;&#160;</a></span>Unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::Unlink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> from its current chain.</p>
<p>Ownership of all elements an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain is normally maintained by the head of the chain. <a class="el" href="#a45cd21c00ea100c65d0a01fb07d70303">Unlink()</a> transfers ownership of this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> from the chain and gives it to the caller. A new unique_ptr to the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> is returned to the caller. The caller must store the returned unique_ptr (or call release() on it) to take ownership, otherwise the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will be immediately destroyed.</p>
<p>Since <a class="el" href="#a45cd21c00ea100c65d0a01fb07d70303">Unlink()</a> transfers ownership of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> to the caller, be careful not to call <a class="el" href="#a45cd21c00ea100c65d0a01fb07d70303">Unlink()</a> on the head of a chain if you already maintain ownership on the head of the chain via other means. The <a class="el" href="#afc8005e47b46e804cf63c89614a2ff2b">pop()</a> method is a better choice for that situation.</p>
<p>\methodset Chaining </p>

</div>
</div>
<a id="a02310eb3c6cfac120d0b7d962097e6ab" name="a02310eb3c6cfac120d0b7d962097e6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02310eb3c6cfac120d0b7d962097e6ab">&#9670;&#160;</a></span>Unshare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::Unshare </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain has unique, unshared buffers.</p>
<p>Multiple IOBufs can point to the same buffer. This means that an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>'s buffer is not necessarily writeable, since another <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> might be using the same underlying data. If you want to write to an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>'s buffer, it is your responsibility to make sure that you aren't trampling the data used by another <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. This can be accomplished by calling <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a>.</p>
<p><a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> ensures that the underlying buffer of each <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> in the chain is not shared with another <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If the current chain has any shared buffers, then <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> might coalesce the chain during unsharing. </dd>
<dd>
Buffers owned by other (non-IOBuf) users are automatically considered to be shared.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The buffers in this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain are all writeable, since they are uniquely owned by the current <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error. On error the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain will be unmodified.</td></tr>
  </table>
  </dd>
</dl>
<p>Currently unshare may also throw std::overflow_error if it tries to coalesce. (TODO: In the future it would be nice if <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> were smart enough not to coalesce the entire buffer if the data is too large. However, in practice this seems unlikely to become an issue.)</p>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="a3a25efa83923b3904420315cfcbbbd0a" name="a3a25efa83923b3904420315cfcbbbd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a25efa83923b3904420315cfcbbbd0a">&#9670;&#160;</a></span>UnshareOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kiwi::IOBuf::UnshareOne </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that this <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> has a unique, unshared buffer.</p>
<p><a class="el" href="#a3a25efa83923b3904420315cfcbbbd0a">UnshareOne()</a> operates on a single <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object. This <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will have a unique buffer after <a class="el" href="#a3a25efa83923b3904420315cfcbbbd0a">UnshareOne()</a> returns, but other IOBufs in the chain may still be shared after <a class="el" href="#a3a25efa83923b3904420315cfcbbbd0a">UnshareOne()</a> returns.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error. On error the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> will be unmodified.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset Buffer Management </p>

</div>
</div>
<a id="a73bd25f5c105b84ef5512ac4563b9dc7" name="a73bd25f5c105b84ef5512ac4563b9dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd25f5c105b84ef5512ac4563b9dc7">&#9670;&#160;</a></span>WrapBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::WrapBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1span.html">ByteRange</a></td>          <td class="paramname"><span class="paramname"><em>br</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a607437c3b69268f69e8f9e1bc91732ba" name="a607437c3b69268f69e8f9e1bc91732ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607437c3b69268f69e8f9e1bc91732ba">&#9670;&#160;</a></span>WrapBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::WrapBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to a buffer, without taking ownership.</p>
<p>This should only be used when the caller knows the lifetime of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object ahead of time and can ensure that all <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects that will point to this buffer will be destroyed before the buffer itself is destroyed. The buffer will not be freed automatically when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> referencing it is destroyed. It is the caller's responsibility to free the buffer after the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> has been destroyed.</p>
<p>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> created using <a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer()</a> will always be reported as shared. <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> may be used to create a writable copy of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange instead of {buf, capacity}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == capacity.    </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>on error (the allocation of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> may throw). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique_ptr to a newly-constructed <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>. @methodset Makers </dd></dl>

</div>
</div>
<a id="a5bb99bd7abf8d1b185d4fe18a80c44ad" name="a5bb99bd7abf8d1b185d4fe18a80c44ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb99bd7abf8d1b185d4fe18a80c44ad">&#9670;&#160;</a></span>WrapBufferAsValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::WrapBufferAsValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkiwi_1_1span.html">ByteRange</a></td>          <td class="paramname"><span class="paramname"><em>br</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a64afb5aeb32475087026e7fa44ef37e8" name="a64afb5aeb32475087026e7fa44ef37e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64afb5aeb32475087026e7fa44ef37e8">&#9670;&#160;</a></span>WrapBufferAsValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> kiwi::IOBuf::WrapBufferAsValue </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> pointing to a buffer, without taking ownership.</p>
<p>This should only be used when the caller knows the lifetime of the <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> object ahead of time and can ensure that all <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> objects that will point to this buffer will be destroyed before the buffer itself is destroyed. The buffer will not be freed automatically when the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> referencing it is destroyed. It is the caller's responsibility to free the buffer after the last <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> has been destroyed.</p>
<p>An <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> created using <a class="el" href="#a607437c3b69268f69e8f9e1bc91732ba">WrapBuffer()</a> will always be reported as shared. <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> may be used to create a writable copy of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The pointer to the buffer </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">br</td><td>Can pass a ByteRange instead of {buf, capacity}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a708944d0de466a93fda5102be9ceb938">data()</a> points to buf. </dd>
<dd>
<a class="el" href="#a73808ff60c3bdbd250e0a4dbf556dd45">Length()</a> == capacity.   </dd></dl>
<p>This static function behaves exactly like the WrapBufferOp constructor. It exists for syntactic parity with the unique_ptr-returning variants.</p>
<dl class="section return"><dt>Returns</dt><dd>A stack-allocated <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> \methodset Makers </dd></dl>

</div>
</div>
<a id="abdc8d5735bb6eaf1b4560c884068313c" name="abdc8d5735bb6eaf1b4560c884068313c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc8d5735bb6eaf1b4560c884068313c">&#9670;&#160;</a></span>WrapIov()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> &gt; kiwi::IOBuf::WrapIov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structiovec.html">iovec</a> *</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an iovec array into an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a>.</p>
<p>A helper that wraps a number of iovecs into an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. If count == 0, then a zero length buf is returned. This function never returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The iovec array to convert to an <a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a> chain. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the iovec array.</td></tr>
  </table>
  </dd>
</dl>
<p>\methodset IOV </p>

</div>
</div>
<a id="a2a17715736ebb6e17e0a1f22fe46fa9a" name="a2a17715736ebb6e17e0a1f22fe46fa9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a17715736ebb6e17e0a1f22fe46fa9a">&#9670;&#160;</a></span>WritableBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * kiwi::IOBuf::WritableBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a writable pointer to the start of the buffer.</p>
<p>The caller is responsible for calling unshare() first to ensure that it is actually safe to write to the buffer.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a05c8383995275986e0534b77a6438a31" name="a05c8383995275986e0534b77a6438a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c8383995275986e0534b77a6438a31">&#9670;&#160;</a></span>WritableData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * kiwi::IOBuf::WritableData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a writable pointer to the start of the data.</p>
<p>The caller is responsible for calling unshare() first to ensure that it is actually safe to write to the buffer.</p>
<p>\methodset Access </p>

</div>
</div>
<a id="a77919d0f48c5fe6895b7fcfa4e48016b" name="a77919d0f48c5fe6895b7fcfa4e48016b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77919d0f48c5fe6895b7fcfa4e48016b">&#9670;&#160;</a></span>WritableTail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * kiwi::IOBuf::WritableTail </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a writable pointer to the end of the data.</p>
<p>The caller is responsible for calling <a class="el" href="#a02310eb3c6cfac120d0b7d962097e6ab">Unshare()</a> first to ensure that it is actually safe to write to the buffer.</p>
<p>\methodset Access </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/kiwi/io/<a class="el" href="iobuf_8hh_source.html">iobuf.hh</a></li>
<li>src/io/<b>iobuf.cc</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacekiwi.html">kiwi</a></li><li class="navelem"><a class="el" href="classkiwi_1_1_i_o_buf.html">IOBuf</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
